"""Semantic color system for daisyUI components"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/colors.ipynb.

# %% auto 0
__all__ = ['ColorClasses', 'ColorBuilder', 'get_color_classes', 'apply_semantic_colors', 'ColorMapping', 'with_opacity',
           'ColorMixin']

# %% ../../nbs/core/colors.ipynb 2
from typing import Union, Optional, List, Dict, Tuple, Literal
from enum import Enum
from dataclasses import dataclass
from functools import lru_cache
from .types import CSSContributor, CSSClasses, SemanticColor, ColorUtility, OpacityLevel

# %% ../../nbs/core/colors.ipynb 4
@dataclass
class ColorClasses:
    """Container for color-related CSS classes"""
    background: Optional[str] = None
    text: Optional[str] = None
    border: Optional[str] = None
    ring: Optional[str] = None
    
    def to_list(
        self
    ) -> List[str]:  # TODO: Add return description
        """Convert to list of class names"""
        classes = []
        if self.background:
            classes.append(self.background)
        if self.text:
            classes.append(self.text)
        if self.border:
            classes.append(self.border)
        if self.ring:
            classes.append(self.ring)
        return classes
    
    def to_string(
        self
    ) -> str:  # TODO: Add return description
        """Convert to space-separated string"""
        return " ".join(self.to_list())

# %% ../../nbs/core/colors.ipynb 5
class ColorBuilder:
    """
    Builder for semantic color classes
    
    Provides a fluent API for building color-related CSS classes
    with daisyUI semantic colors.
    """
    
    def __init__(self):
        "TODO: Add function description"
        self._classes = ColorClasses()
    
    def bg(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set background color"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(color)
        return self
    
    def text(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set text color"""
        self._classes.text = ColorUtility.TEXT.with_color(color)
        return self
    
    def border(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set border color"""
        self._classes.border = ColorUtility.BORDER.with_color(color)
        return self
    
    def ring(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set ring color"""
        self._classes.ring = ColorUtility.RING.with_color(color)
        return self
    
    def brand_primary(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply primary brand colors (background + appropriate text)"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.PRIMARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.PRIMARY_CONTENT)
        return self
    
    def brand_secondary(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply secondary brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SECONDARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SECONDARY_CONTENT)
        return self
    
    def brand_accent(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply accent brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ACCENT)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ACCENT_CONTENT)
        return self
    
    def state_info(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply info state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.INFO)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.INFO_CONTENT)
        return self
    
    def state_success(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply success state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SUCCESS)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SUCCESS_CONTENT)
        return self
    
    def state_warning(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply warning state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.WARNING)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.WARNING_CONTENT)
        return self
    
    def state_error(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply error state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ERROR)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ERROR_CONTENT)
        return self
    
    def surface_base(
        self,
        level: Literal[100, 200, 300] = 100  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply base surface colors"""
        base_color = {
            100: SemanticColor.BASE_100,
            200: SemanticColor.BASE_200,
            300: SemanticColor.BASE_300,
        }[level]
        self._classes.background = ColorUtility.BACKGROUND.with_color(base_color)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.BASE_CONTENT)
        return self
    
    def build(
        self
    ) -> str:  # TODO: Add return description
        """Build the final class string"""
        return self._classes.to_string()
    
    def build_list(
        self
    ) -> List[str]:  # TODO: Add return description
        """Build as a list of classes"""
        return self._classes.to_list()
    
    def reset(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Reset the builder"""
        self._classes = ColorClasses()
        return self

# %% ../../nbs/core/colors.ipynb 7
@lru_cache(maxsize=128)
def get_color_classes(
    color: Union[SemanticColor, str],
    utilities: List[ColorUtility] = None  # List of utilities to generate (defaults to bg and text)
) -> List[str]:  # List of CSS class names
    "Generate color utility classes for a semantic color"
    if utilities is None:
        utilities = [ColorUtility.BACKGROUND, ColorUtility.TEXT]
    
    return [utility.with_color(color) for utility in utilities]

# %% ../../nbs/core/colors.ipynb 8
def apply_semantic_colors(
    bg: Optional[Union[SemanticColor, str]] = None,
    text: Optional[Union[SemanticColor, str]] = None,
    border: Optional[Union[SemanticColor, str]] = None,
    auto_content: bool = True  # Automatically select appropriate text color for background
) -> str:  # Space-separated CSS classes
    "Apply semantic colors with automatic content color selection"
    classes = []
    
    # Add background
    if bg:
        classes.append(ColorUtility.BACKGROUND.with_color(bg))
        
        # Auto-select text color if needed
        if auto_content and not text and isinstance(bg, SemanticColor):
            if not bg.is_content_color():
                content_color = bg.with_content()
                classes.append(ColorUtility.TEXT.with_color(content_color))
    
    # Add explicit text color
    if text:
        classes.append(ColorUtility.TEXT.with_color(text))
    
    # Add border
    if border:
        classes.append(ColorUtility.BORDER.with_color(border))
    
    return " ".join(classes)

# %% ../../nbs/core/colors.ipynb 10
class ColorMapping:
    """Pre-defined color mappings for common use cases"""
    
    # Component state mappings
    STATE_COLORS: Dict[str, SemanticColor] = {
        "active": SemanticColor.PRIMARY,
        "hover": SemanticColor.PRIMARY,
        "focus": SemanticColor.PRIMARY,
        "disabled": SemanticColor.NEUTRAL,
        "loading": SemanticColor.NEUTRAL,
        "success": SemanticColor.SUCCESS,
        "error": SemanticColor.ERROR,
        "warning": SemanticColor.WARNING,
        "info": SemanticColor.INFO,
    }
    
    # Severity/priority mappings
    SEVERITY_COLORS: Dict[str, SemanticColor] = {
        "critical": SemanticColor.ERROR,
        "high": SemanticColor.WARNING,
        "medium": SemanticColor.INFO,
        "low": SemanticColor.NEUTRAL,
    }
    
    # Status mappings
    STATUS_COLORS: Dict[str, SemanticColor] = {
        "online": SemanticColor.SUCCESS,
        "offline": SemanticColor.NEUTRAL,
        "away": SemanticColor.WARNING,
        "busy": SemanticColor.ERROR,
        "available": SemanticColor.SUCCESS,
    }
    
    @classmethod
    def get_state_color(
        cls,  # TODO: Add type hint and description
        state: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a component state"""
        return cls.STATE_COLORS.get(state.lower())
    
    @classmethod
    def get_severity_color(
        cls,  # TODO: Add type hint and description
        severity: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a severity level"""
        return cls.SEVERITY_COLORS.get(severity.lower())
    
    @classmethod
    def get_status_color(
        cls,  # TODO: Add type hint and description
        status: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a status"""
        return cls.STATUS_COLORS.get(status.lower())

# %% ../../nbs/core/colors.ipynb 12
def with_opacity(
    color_class: str,  # The color utility class (e.g., "bg-primary")
    opacity: Union[OpacityLevel, int]
) -> str:  # Color class with opacity modifier
    "Add opacity modifier to a color class"
    opacity_value = opacity.value if isinstance(opacity, OpacityLevel) else opacity
    return f"{color_class}/{opacity_value}"

# %% ../../nbs/core/colors.ipynb 23
class ColorMixin(CSSContributor):
    """
    Mixin to add semantic color support to components
    
    This will be used by DaisyComponent to provide color methods.
    """
    
    def with_color(
        self,
        color: Union[SemanticColor, str],
        apply_to: List[ColorUtility] = None  # TODO: Add description
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply a semantic color to the component"""
        if not hasattr(self, '_color_classes'):
            self._color_classes = []
        
        utilities = apply_to or [ColorUtility.BACKGROUND, ColorUtility.TEXT]
        for utility in utilities:
            self._color_classes.append(utility.with_color(color))
        
        return self
    
    def with_brand_colors(
        self,
        brand: Literal["primary", "secondary", "accent", "neutral"]
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply brand colors with appropriate text color"""
        color_map = {
            "primary": (SemanticColor.PRIMARY, SemanticColor.PRIMARY_CONTENT),
            "secondary": (SemanticColor.SECONDARY, SemanticColor.SECONDARY_CONTENT),
            "accent": (SemanticColor.ACCENT, SemanticColor.ACCENT_CONTENT),
            "neutral": (SemanticColor.NEUTRAL, SemanticColor.NEUTRAL_CONTENT),
        }
        
        if brand in color_map:
            bg_color, text_color = color_map[brand]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def with_state_colors(
        self,
        state: Literal["info", "success", "warning", "error"]
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply state colors with appropriate text color"""
        color_map = {
            "info": (SemanticColor.INFO, SemanticColor.INFO_CONTENT),
            "success": (SemanticColor.SUCCESS, SemanticColor.SUCCESS_CONTENT),
            "warning": (SemanticColor.WARNING, SemanticColor.WARNING_CONTENT),
            "error": (SemanticColor.ERROR, SemanticColor.ERROR_CONTENT),
        }
        
        if state in color_map:
            bg_color, text_color = color_map[state]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def get_css_classes(self) -> CSSClasses:
        """Get all color classes applied to this component
        
        Returns:
            List of CSS class strings for colors
        """
        return getattr(self, '_color_classes', [])
