"""Semantic color system for daisyUI components"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/colors.ipynb.

# %% auto 0
__all__ = ['ColorClasses', 'ColorBuilder', 'get_color_classes', 'apply_semantic_colors', 'with_opacity', 'ColorMixin']

# %% ../../nbs/core/colors.ipynb 2
from typing import Union, Optional, List, Dict, Tuple, Literal
from enum import Enum
from dataclasses import dataclass
from functools import lru_cache
from .types import CSSContributor, SemanticColor, ColorUtility, OpacityLevel, BaseColor

# %% ../../nbs/core/colors.ipynb 4
@dataclass
class ColorClasses:
    """Container for color-related CSS classes"""
    background: Optional[str] = None
    text: Optional[str] = None
    border: Optional[str] = None
    ring: Optional[str] = None
    
    def to_list(
        self
    ) -> List[str]:  # List of class names
        """Convert to list of class names"""
        classes = []
        if self.background:
            classes.append(self.background)
        if self.text:
            classes.append(self.text)
        if self.border:
            classes.append(self.border)
        if self.ring:
            classes.append(self.ring)
        return classes
    
    def to_string(
        self
    ) -> str:  # Space-separated string
        """Convert to space-separated string"""
        return " ".join(self.to_list())

# %% ../../nbs/core/colors.ipynb 5
class ColorBuilder:
    """
    Builder for semantic color classes
    
    Provides a fluent API for building color-related CSS classes
    with daisyUI semantic colors.
    """
    
    def __init__(self):
        "Initialize a new ColorBuilder with empty color classes"
        self._classes = ColorClasses()
    
    def bg(
        self,
        color: Union[SemanticColor, str]  # background color
    ) -> "ColorBuilder":  # Self for method chaining
        """Set background color"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(color)
        return self
    
    def text(
        self,
        color: Union[SemanticColor, str]  # text color
    ) -> "ColorBuilder":  # Self for method chaining
        """Set text color"""
        self._classes.text = ColorUtility.TEXT.with_color(color)
        return self
    
    def border(
        self,
        color: Union[SemanticColor, str]  # Border color
    ) -> "ColorBuilder":  # Self for method chaining
        """Set border color"""
        self._classes.border = ColorUtility.BORDER.with_color(color)
        return self
    
    def ring(
        self,
        color: Union[SemanticColor, str]  # Ring color
    ) -> "ColorBuilder":  # Self for method chaining
        """Set ring color"""
        self._classes.ring = ColorUtility.RING.with_color(color)
        return self
    
    def brand_primary(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply primary brand colors (background + appropriate text)"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.PRIMARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.PRIMARY_CONTENT)
        return self
    
    def brand_secondary(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply secondary brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SECONDARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SECONDARY_CONTENT)
        return self
    
    def brand_accent(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply accent brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ACCENT)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ACCENT_CONTENT)
        return self
    
    def state_info(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply info state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.INFO)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.INFO_CONTENT)
        return self
    
    def state_success(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply success state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SUCCESS)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SUCCESS_CONTENT)
        return self
    
    def state_warning(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply warning state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.WARNING)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.WARNING_CONTENT)
        return self
    
    def state_error(
        self
    ) -> "ColorBuilder":  # Self for method chaining
        """Apply error state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ERROR)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ERROR_CONTENT)
        return self
    
    def surface_base(
        self,
        level: BaseColor = 100  # Base level
    ) -> "ColorBuilder":   # Self for method chaining
        """Apply base surface colors"""
        base_color = {
            100: SemanticColor.BASE_100,
            200: SemanticColor.BASE_200,
            300: SemanticColor.BASE_300,
        }[level]
        self._classes.background = ColorUtility.BACKGROUND.with_color(base_color)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.BASE_CONTENT)
        return self
    
    def build(
        self
    ) -> str:  # Final class string
        """Build the final class string"""
        return self._classes.to_string()
    
    def build_list(
        self
    ) -> List[str]:  # List of classes
        """Build as a list of classes"""
        return self._classes.to_list()
    
    def reset(
        self
    ) -> "ColorBuilder":   # Self for method chaining
        """Reset the builder"""
        self._classes = ColorClasses()
        return self

# %% ../../nbs/core/colors.ipynb 7
@lru_cache(maxsize=128)
def get_color_classes(
    color: Union[SemanticColor, str],
    utilities: List[ColorUtility] = None  # List of utilities to generate (defaults to bg and text)
) -> List[str]:  # List of CSS class names
    "Generate color utility classes for a semantic color"
    if utilities is None:
        utilities = [ColorUtility.BACKGROUND, ColorUtility.TEXT]
    
    return [utility.with_color(color) for utility in utilities]

# %% ../../nbs/core/colors.ipynb 8
def apply_semantic_colors(
    bg: Optional[Union[SemanticColor, str]] = None,
    text: Optional[Union[SemanticColor, str]] = None,
    border: Optional[Union[SemanticColor, str]] = None,
    auto_content: bool = True  # Automatically select appropriate text color for background
) -> str:  # Space-separated CSS classes
    "Apply semantic colors with automatic content color selection"
    classes = []
    
    # Add background
    if bg:
        classes.append(ColorUtility.BACKGROUND.with_color(bg))
        
        # Auto-select text color if needed
        if auto_content and not text and isinstance(bg, SemanticColor):
            if not bg.is_content_color():
                content_color = bg.with_content()
                classes.append(ColorUtility.TEXT.with_color(content_color))
    
    # Add explicit text color
    if text:
        classes.append(ColorUtility.TEXT.with_color(text))
    
    # Add border
    if border:
        classes.append(ColorUtility.BORDER.with_color(border))
    
    return " ".join(classes)

# %% ../../nbs/core/colors.ipynb 10
def with_opacity(
    color_class: str,  # The color utility class (e.g., "bg-primary")
    opacity: Union[OpacityLevel, int]
) -> str:  # Color class with opacity modifier
    "Add opacity modifier to a color class"
    opacity_value = opacity.value if isinstance(opacity, OpacityLevel) else opacity
    return f"{color_class}/{opacity_value}"

# %% ../../nbs/core/colors.ipynb 19
class ColorMixin(CSSContributor):
    """
    Mixin to add semantic color support to components
    
    This will be used by DaisyComponent to provide color methods.
    """
    
    def with_color(
        self,
        color: Union[SemanticColor, str],
        apply_to: List[ColorUtility] = None  # Utilities to apply color to (defaults to bg and text)
    ) -> "ColorMixin":  # Self for method chaining
        """Apply a semantic color to the component"""
        if not hasattr(self, '_color_classes'):
            self._color_classes = []
        
        utilities = apply_to or [ColorUtility.BACKGROUND, ColorUtility.TEXT]
        for utility in utilities:
            self._color_classes.append(utility.with_color(color))
        
        return self
    
    def with_brand_colors(
        self,
        brand: Literal["primary", "secondary", "accent", "neutral"]
    ) -> "ColorMixin":  # Self for method chaining
        """Apply brand colors with appropriate text color"""
        color_map = {
            "primary": (SemanticColor.PRIMARY, SemanticColor.PRIMARY_CONTENT),
            "secondary": (SemanticColor.SECONDARY, SemanticColor.SECONDARY_CONTENT),
            "accent": (SemanticColor.ACCENT, SemanticColor.ACCENT_CONTENT),
            "neutral": (SemanticColor.NEUTRAL, SemanticColor.NEUTRAL_CONTENT),
        }
        
        if brand in color_map:
            bg_color, text_color = color_map[brand]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def with_state_colors(
        self,
        state: Literal["info", "success", "warning", "error"]
    ) -> "ColorMixin":  # Self for method chaining
        """Apply state colors with appropriate text color"""
        color_map = {
            "info": (SemanticColor.INFO, SemanticColor.INFO_CONTENT),
            "success": (SemanticColor.SUCCESS, SemanticColor.SUCCESS_CONTENT),
            "warning": (SemanticColor.WARNING, SemanticColor.WARNING_CONTENT),
            "error": (SemanticColor.ERROR, SemanticColor.ERROR_CONTENT),
        }
        
        if state in color_map:
            bg_color, text_color = color_map[state]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def get_css_classes(
        self
    ) -> List[str]:  # List of CSS class strings for colors
        """Get all color classes applied to this component
        
        Returns:
            List of CSS class strings for colors
        """
        return getattr(self, '_color_classes', [])
