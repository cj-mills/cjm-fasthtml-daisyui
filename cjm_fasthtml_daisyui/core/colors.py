"""Semantic color system for daisyUI components"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/colors.ipynb.

# %% auto 0
__all__ = ['SemanticColor', 'ColorUtility', 'ColorClasses', 'ColorBuilder', 'get_color_classes', 'apply_semantic_colors',
           'ColorMapping', 'OpacityLevel', 'with_opacity', 'ColorMixin']

# %% ../../nbs/core/colors.ipynb 2
from typing import Union, Optional, List, Dict, Tuple, Literal
from enum import Enum
from dataclasses import dataclass
from functools import lru_cache

# %% ../../nbs/core/colors.ipynb 4
class SemanticColor(str, Enum):
    """
    daisyUI semantic colors that adapt to themes
    
    These colors change based on the active theme, providing
    consistent semantic meaning across different visual styles.
    """
    # Brand colors
    PRIMARY = "primary"
    SECONDARY = "secondary"
    ACCENT = "accent"
    NEUTRAL = "neutral"
    
    # Base colors for surfaces
    BASE_100 = "base-100"  # Main background
    BASE_200 = "base-200"  # Slightly darker
    BASE_300 = "base-300"  # Even darker
    BASE_CONTENT = "base-content"  # Text on base colors
    
    # State colors
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    
    # Content colors (for text on colored backgrounds)
    PRIMARY_CONTENT = "primary-content"
    SECONDARY_CONTENT = "secondary-content"
    ACCENT_CONTENT = "accent-content"
    NEUTRAL_CONTENT = "neutral-content"
    INFO_CONTENT = "info-content"
    SUCCESS_CONTENT = "success-content"
    WARNING_CONTENT = "warning-content"
    ERROR_CONTENT = "error-content"
    
    def with_content(
        self
    ) -> "SemanticColor":  # TODO: Add return description
        """Get the corresponding content color for this semantic color"""
        content_map = {
            self.PRIMARY: self.PRIMARY_CONTENT,
            self.SECONDARY: self.SECONDARY_CONTENT,
            self.ACCENT: self.ACCENT_CONTENT,
            self.NEUTRAL: self.NEUTRAL_CONTENT,
            self.INFO: self.INFO_CONTENT,
            self.SUCCESS: self.SUCCESS_CONTENT,
            self.WARNING: self.WARNING_CONTENT,
            self.ERROR: self.ERROR_CONTENT,
        }
        return content_map.get(self, self.BASE_CONTENT)
    
    def is_brand_color(
        self
    ) -> bool:  # TODO: Add return description
        """Check if this is a brand color"""
        return self in {self.PRIMARY, self.SECONDARY, self.ACCENT, self.NEUTRAL}
    
    def is_state_color(
        self
    ) -> bool:  # TODO: Add return description
        """Check if this is a state/semantic color"""
        return self in {self.INFO, self.SUCCESS, self.WARNING, self.ERROR}
    
    def is_base_color(
        self
    ) -> bool:  # TODO: Add return description
        """Check if this is a base/surface color"""
        return self in {self.BASE_100, self.BASE_200, self.BASE_300, self.BASE_CONTENT}
    
    def is_content_color(
        self
    ) -> bool:  # TODO: Add return description
        """Check if this is a content/text color"""
        return self.value.endswith("-content")

# %% ../../nbs/core/colors.ipynb 5
class ColorUtility(str, Enum):
    """CSS utility prefixes that work with semantic colors"""
    BACKGROUND = "bg"
    TEXT = "text"
    BORDER = "border"
    RING = "ring"
    RING_OFFSET = "ring-offset"
    DIVIDE = "divide"
    OUTLINE = "outline"
    DECORATION = "decoration"
    FILL = "fill"
    STROKE = "stroke"
    
    def with_color(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> str:  # TODO: Add return description
        """Generate a utility class with a color"""
        color_value = color.value if isinstance(color, SemanticColor) else color
        return f"{self.value}-{color_value}"

# %% ../../nbs/core/colors.ipynb 7
@dataclass
class ColorClasses:
    """Container for color-related CSS classes"""
    background: Optional[str] = None
    text: Optional[str] = None
    border: Optional[str] = None
    ring: Optional[str] = None
    
    def to_list(
        self
    ) -> List[str]:  # TODO: Add return description
        """Convert to list of class names"""
        classes = []
        if self.background:
            classes.append(self.background)
        if self.text:
            classes.append(self.text)
        if self.border:
            classes.append(self.border)
        if self.ring:
            classes.append(self.ring)
        return classes
    
    def to_string(
        self
    ) -> str:  # TODO: Add return description
        """Convert to space-separated string"""
        return " ".join(self.to_list())

# %% ../../nbs/core/colors.ipynb 8
class ColorBuilder:
    """
    Builder for semantic color classes
    
    Provides a fluent API for building color-related CSS classes
    with daisyUI semantic colors.
    """
    
    def __init__(self):
        "TODO: Add function description"
        self._classes = ColorClasses()
    
    def bg(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set background color"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(color)
        return self
    
    def text(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set text color"""
        self._classes.text = ColorUtility.TEXT.with_color(color)
        return self
    
    def border(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set border color"""
        self._classes.border = ColorUtility.BORDER.with_color(color)
        return self
    
    def ring(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Set ring color"""
        self._classes.ring = ColorUtility.RING.with_color(color)
        return self
    
    def brand_primary(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply primary brand colors (background + appropriate text)"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.PRIMARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.PRIMARY_CONTENT)
        return self
    
    def brand_secondary(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply secondary brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SECONDARY)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SECONDARY_CONTENT)
        return self
    
    def brand_accent(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply accent brand colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ACCENT)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ACCENT_CONTENT)
        return self
    
    def state_info(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply info state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.INFO)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.INFO_CONTENT)
        return self
    
    def state_success(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply success state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.SUCCESS)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.SUCCESS_CONTENT)
        return self
    
    def state_warning(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply warning state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.WARNING)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.WARNING_CONTENT)
        return self
    
    def state_error(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply error state colors"""
        self._classes.background = ColorUtility.BACKGROUND.with_color(SemanticColor.ERROR)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.ERROR_CONTENT)
        return self
    
    def surface_base(
        self,
        level: Literal[100, 200, 300] = 100  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
        """Apply base surface colors"""
        base_color = {
            100: SemanticColor.BASE_100,
            200: SemanticColor.BASE_200,
            300: SemanticColor.BASE_300,
        }[level]
        self._classes.background = ColorUtility.BACKGROUND.with_color(base_color)
        self._classes.text = ColorUtility.TEXT.with_color(SemanticColor.BASE_CONTENT)
        return self
    
    def build(
        self
    ) -> str:  # TODO: Add return description
        """Build the final class string"""
        return self._classes.to_string()
    
    def build_list(
        self
    ) -> List[str]:  # TODO: Add return description
        """Build as a list of classes"""
        return self._classes.to_list()
    
    def reset(
        self
    ) -> "ColorBuilder":  # TODO: Add return description
        """Reset the builder"""
        self._classes = ColorClasses()
        return self

# %% ../../nbs/core/colors.ipynb 10
@lru_cache(maxsize=128)
def get_color_classes(
    color: Union[SemanticColor, str],
    utilities: List[ColorUtility] = None  # List of utilities to generate (defaults to bg and text)
) -> List[str]:  # List of CSS class names
    "Generate color utility classes for a semantic color"
    if utilities is None:
        utilities = [ColorUtility.BACKGROUND, ColorUtility.TEXT]
    
    return [utility.with_color(color) for utility in utilities]

# %% ../../nbs/core/colors.ipynb 11
def apply_semantic_colors(
    bg: Optional[Union[SemanticColor, str]] = None,
    text: Optional[Union[SemanticColor, str]] = None,
    border: Optional[Union[SemanticColor, str]] = None,
    auto_content: bool = True  # Automatically select appropriate text color for background
) -> str:  # Space-separated CSS classes
    "Apply semantic colors with automatic content color selection"
    classes = []
    
    # Add background
    if bg:
        classes.append(ColorUtility.BACKGROUND.with_color(bg))
        
        # Auto-select text color if needed
        if auto_content and not text and isinstance(bg, SemanticColor):
            if not bg.is_content_color():
                content_color = bg.with_content()
                classes.append(ColorUtility.TEXT.with_color(content_color))
    
    # Add explicit text color
    if text:
        classes.append(ColorUtility.TEXT.with_color(text))
    
    # Add border
    if border:
        classes.append(ColorUtility.BORDER.with_color(border))
    
    return " ".join(classes)

# %% ../../nbs/core/colors.ipynb 13
class ColorMapping:
    """Pre-defined color mappings for common use cases"""
    
    # Component state mappings
    STATE_COLORS: Dict[str, SemanticColor] = {
        "active": SemanticColor.PRIMARY,
        "hover": SemanticColor.PRIMARY,
        "focus": SemanticColor.PRIMARY,
        "disabled": SemanticColor.NEUTRAL,
        "loading": SemanticColor.NEUTRAL,
        "success": SemanticColor.SUCCESS,
        "error": SemanticColor.ERROR,
        "warning": SemanticColor.WARNING,
        "info": SemanticColor.INFO,
    }
    
    # Severity/priority mappings
    SEVERITY_COLORS: Dict[str, SemanticColor] = {
        "critical": SemanticColor.ERROR,
        "high": SemanticColor.WARNING,
        "medium": SemanticColor.INFO,
        "low": SemanticColor.NEUTRAL,
    }
    
    # Status mappings
    STATUS_COLORS: Dict[str, SemanticColor] = {
        "online": SemanticColor.SUCCESS,
        "offline": SemanticColor.NEUTRAL,
        "away": SemanticColor.WARNING,
        "busy": SemanticColor.ERROR,
        "available": SemanticColor.SUCCESS,
    }
    
    @classmethod
    def get_state_color(
        cls,  # TODO: Add type hint and description
        state: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a component state"""
        return cls.STATE_COLORS.get(state.lower())
    
    @classmethod
    def get_severity_color(
        cls,  # TODO: Add type hint and description
        severity: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a severity level"""
        return cls.SEVERITY_COLORS.get(severity.lower())
    
    @classmethod
    def get_status_color(
        cls,  # TODO: Add type hint and description
        status: str  # TODO: Add description
    ) -> Optional[SemanticColor]:  # TODO: Add return description
        """Get semantic color for a status"""
        return cls.STATUS_COLORS.get(status.lower())

# %% ../../nbs/core/colors.ipynb 15
class OpacityLevel(int, Enum):
    """Standard opacity levels"""
    OPACITY_0 = 0
    OPACITY_5 = 5
    OPACITY_10 = 10
    OPACITY_20 = 20
    OPACITY_25 = 25
    OPACITY_30 = 30
    OPACITY_40 = 40
    OPACITY_50 = 50
    OPACITY_60 = 60
    OPACITY_70 = 70
    OPACITY_75 = 75
    OPACITY_80 = 80
    OPACITY_90 = 90
    OPACITY_95 = 95
    OPACITY_100 = 100

# %% ../../nbs/core/colors.ipynb 16
def with_opacity(
    color_class: str,  # The color utility class (e.g., "bg-primary")
    opacity: Union[OpacityLevel, int]
) -> str:  # Color class with opacity modifier
    "Add opacity modifier to a color class"
    opacity_value = opacity.value if isinstance(opacity, OpacityLevel) else opacity
    return f"{color_class}/{opacity_value}"

# %% ../../nbs/core/colors.ipynb 27
class ColorMixin:
    """
    Mixin to add semantic color support to components
    
    This will be used by DaisyComponent to provide color methods.
    """
    
    def with_color(
        self,
        color: Union[SemanticColor, str],
        apply_to: List[ColorUtility] = None  # TODO: Add description
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply a semantic color to the component"""
        if not hasattr(self, '_color_classes'):
            self._color_classes = []
        
        utilities = apply_to or [ColorUtility.BACKGROUND, ColorUtility.TEXT]
        for utility in utilities:
            self._color_classes.append(utility.with_color(color))
        
        return self
    
    def with_brand_colors(
        self,
        brand: Literal["primary", "secondary", "accent", "neutral"]
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply brand colors with appropriate text color"""
        color_map = {
            "primary": (SemanticColor.PRIMARY, SemanticColor.PRIMARY_CONTENT),
            "secondary": (SemanticColor.SECONDARY, SemanticColor.SECONDARY_CONTENT),
            "accent": (SemanticColor.ACCENT, SemanticColor.ACCENT_CONTENT),
            "neutral": (SemanticColor.NEUTRAL, SemanticColor.NEUTRAL_CONTENT),
        }
        
        if brand in color_map:
            bg_color, text_color = color_map[brand]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def with_state_colors(
        self,
        state: Literal["info", "success", "warning", "error"]
    ) -> "ColorMixin":  # TODO: Add return description
        """Apply state colors with appropriate text color"""
        color_map = {
            "info": (SemanticColor.INFO, SemanticColor.INFO_CONTENT),
            "success": (SemanticColor.SUCCESS, SemanticColor.SUCCESS_CONTENT),
            "warning": (SemanticColor.WARNING, SemanticColor.WARNING_CONTENT),
            "error": (SemanticColor.ERROR, SemanticColor.ERROR_CONTENT),
        }
        
        if state in color_map:
            bg_color, text_color = color_map[state]
            self.with_color(bg_color, [ColorUtility.BACKGROUND])
            self.with_color(text_color, [ColorUtility.TEXT])
        
        return self
    
    def get_color_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Get all color classes applied to this component"""
        return getattr(self, '_color_classes', [])
