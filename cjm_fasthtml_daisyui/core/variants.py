"""System for handling component variants and states"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/variants.ipynb.

# %% auto 0
__all__ = ['HasGlass', 'Variant', 'HasVariants', 'CompoundVariant', 'HasCompoundVariants', 'create_style_variant']

# %% ../../nbs/core/variants.ipynb 3
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
from .types import CSSContributor, CSSClasses, StyleType

# %% ../../nbs/core/variants.ipynb 6
@dataclass
class HasGlass(CSSContributor):
    """Mixin for components that support glass morphism effect.
    
    This mixin provides the glass effect styling for daisyUI components.
    The glass effect creates a frosted glass appearance.
    """
    
    # Glass effect property
    glass: bool = False
    
    def get_css_classes(
        self
    ) -> CSSClasses:  # List of CSS class strings for glass effect
        """Get glass effect CSS classes.
        
        Returns:
            List of CSS class strings for glass effect
        """
        if self.glass:
            return ["glass"]
        return []

# %% ../../nbs/core/variants.ipynb 7
@dataclass
class Variant:
    """Represents a component variant.
    
    Variants allow components to have different appearances based on props.
    Inspired by CVA (Class Variance Authority) pattern.
    """
    name: str  # Variant name (e.g., 'intent', 'size')
    options: Dict[str, Union[str, List[str]]]  # Option -> classes mapping
    default: Optional[str] = None  # Default option
    
    def get_classes(
        self,
        value: Optional[str]  # The variant option value to get classes for
    ) -> List[str]:  # List of CSS class strings for the variant value
        """Get classes for a variant value."""
        if value is None:
            value = self.default
            
        if value is None or value not in self.options:
            return []
            
        classes = self.options[value]
        if isinstance(classes, str):
            return classes.split()
        return classes

# %% ../../nbs/core/variants.ipynb 9
class HasVariants(CSSContributor):
    """Mixin for components with variant support.
    
    This provides a more flexible alternative to individual boolean flags
    for component variations.
    """
    
    # Variant values (set by subclasses)
    variant_values: Dict[str, Optional[str]] = field(default_factory=dict)
    
    @classmethod
    def variants(
        cls  # The class type
    ) -> Dict[str, Variant]:  # Dictionary mapping variant names to Variant objects
        """Define available variants.
        
        Subclasses should override this to define their variants.
        """
        return {}
    
    def get_css_classes(
        self
    ) -> CSSClasses:  # List of CSS class strings from all active variants
        """Get all classes from variants.
        
        Returns:
            List of CSS class strings from variants
        """
        classes = []
        variants = self.variants()
        
        for variant_name, variant in variants.items():
            value = self.variant_values.get(variant_name)
            classes.extend(variant.get_classes(value))
            
        return classes
    
    def set_variant(
        self,
        name: str,  # The variant name to set
        value: str  # The variant value to apply
    ) -> 'HasVariants':  # Self for method chaining
        """Set a variant value and return self for chaining."""
        self.variant_values[name] = value
        return self

# %% ../../nbs/core/variants.ipynb 11
@dataclass
class CompoundVariant:
    """Represents a compound variant that depends on multiple conditions."""
    conditions: Dict[str, str]  # variant_name -> required_value
    classes: Union[str, List[str]]  # Classes to apply when conditions met
    
    def matches(
        self,
        variant_values: Dict[str, Optional[str]]  # Current variant values to check against conditions
    ) -> bool:  # True if all conditions are met, False otherwise
        """Check if all conditions are met."""
        for variant_name, required_value in self.conditions.items():
            if variant_values.get(variant_name) != required_value:
                return False
        return True
    
    def get_classes(
        self
    ) -> List[str]:  # List of CSS class strings for this compound variant
        """Get classes for this compound variant."""
        if isinstance(self.classes, str):
            return self.classes.split()
        return self.classes

# %% ../../nbs/core/variants.ipynb 12
class HasCompoundVariants(HasVariants):
    """Extended mixin that supports compound variants."""
    
    @classmethod
    def compound_variants(
        cls  # The class type
    ) -> List[CompoundVariant]:  # List of compound variant definitions
        """Define compound variants.
        
        Subclasses should override this to define compound variants.
        """
        return []
    
    def get_css_classes(
        self
    ) -> CSSClasses:  # List of CSS class strings from variants and compound variants
        """Get all classes from variants including compound variants.
        
        Returns:
            List of CSS class strings from variants and compound variants
        """
        classes = super().get_css_classes()
        
        # Check compound variants
        for compound in self.compound_variants():
            if compound.matches(self.variant_values):
                classes.extend(compound.get_classes())
                
        return classes

# %% ../../nbs/core/variants.ipynb 14
# Helper function to create style variant for a specific component
def create_style_variant(
    component_prefix: str  # The component prefix (e.g., 'btn', 'badge')
) -> Variant:  # Variant with component-specific style classes
    "Create a style variant with component-specific class names."
    return Variant(
        name="style",
        options={
            style.value: f"{component_prefix}-{style.value}"
            for style in StyleType
        },
        default=None
    )
