"""System for handling component variants and states"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/variants.ipynb.

# %% auto 0
__all__ = ['Variant', 'HasVariants', 'CompoundVariant', 'HasCompoundVariants']

# %% ../../nbs/core/variants.ipynb 3
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field

# %% ../../nbs/core/variants.ipynb 5
@dataclass
class Variant:
    """Represents a component variant.
    
    Variants allow components to have different appearances based on props.
    Inspired by CVA (Class Variance Authority) pattern.
    """
    name: str  # Variant name (e.g., 'intent', 'size')
    options: Dict[str, Union[str, List[str]]]  # Option -> classes mapping
    default: Optional[str] = None  # Default option
    
    def get_classes(
        self,
        value: Optional[str]  # TODO: Add description
    ) -> List[str]:  # TODO: Add return description
        """Get classes for a variant value."""
        if value is None:
            value = self.default
            
        if value is None or value not in self.options:
            return []
            
        classes = self.options[value]
        if isinstance(classes, str):
            return classes.split()
        return classes

# %% ../../nbs/core/variants.ipynb 7
class HasVariants:
    """Mixin for components with variant support.
    
    This provides a more flexible alternative to individual boolean flags
    for component variations.
    """
    
    # Variant values (set by subclasses)
    variant_values: Dict[str, Optional[str]] = field(default_factory=dict)
    
    @classmethod
    def variants(
        cls  # TODO: Add type hint and description
    ) -> Dict[str, Variant]:  # TODO: Add return description
        """Define available variants.
        
        Subclasses should override this to define their variants.
        """
        return {}
    
    def variant_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Get all classes from variants."""
        classes = []
        variants = self.variants()
        
        for variant_name, variant in variants.items():
            value = self.variant_values.get(variant_name)
            classes.extend(variant.get_classes(value))
            
        return classes
    
    def set_variant(
        self,
        name: str,  # TODO: Add description
        value: str  # TODO: Add description
    ) -> 'HasVariants':  # TODO: Add return description
        """Set a variant value and return self for chaining."""
        self.variant_values[name] = value
        return self

# %% ../../nbs/core/variants.ipynb 9
@dataclass
class CompoundVariant:
    """Represents a compound variant that depends on multiple conditions."""
    conditions: Dict[str, str]  # variant_name -> required_value
    classes: Union[str, List[str]]  # Classes to apply when conditions met
    
    def matches(
        self,
        variant_values: Dict[str, Optional[str]]  # TODO: Add description
    ) -> bool:  # TODO: Add return description
        """Check if all conditions are met."""
        for variant_name, required_value in self.conditions.items():
            if variant_values.get(variant_name) != required_value:
                return False
        return True
    
    def get_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Get classes for this compound variant."""
        if isinstance(self.classes, str):
            return self.classes.split()
        return self.classes

# %% ../../nbs/core/variants.ipynb 10
class HasCompoundVariants(HasVariants):
    """Extended mixin that supports compound variants."""
    
    @classmethod
    def compound_variants(
        cls  # TODO: Add type hint and description
    ) -> List[CompoundVariant]:  # TODO: Add return description
        """Define compound variants.
        
        Subclasses should override this to define compound variants.
        """
        return []
    
    def variant_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Get all classes from variants including compound variants."""
        classes = super().variant_classes()
        
        # Check compound variants
        for compound in self.compound_variants():
            if compound.matches(self.variant_values):
                classes.extend(compound.get_classes())
                
        return classes
