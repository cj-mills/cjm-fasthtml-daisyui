"""System for handling style modifiers (outline, ghost, soft, etc.)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/modifiers.ipynb.

# %% auto 0
__all__ = ['StyleType', 'CardModifier', 'InputModifier', 'StyleModifier', 'HasStyles']

# %% ../../nbs/core/modifiers.ipynb 3
from typing import Dict, Optional, List, Union
from dataclasses import dataclass, field
from enum import Enum

# %% ../../nbs/core/modifiers.ipynb 5
class StyleType(str, Enum):
    """Common style modifiers across components."""
    OUTLINE = "outline"
    GHOST = "ghost"
    SOFT = "soft"
    DASH = "dash"
    BORDER = "border"
    LINK = "link"
    GLASS = "glass"

# %% ../../nbs/core/modifiers.ipynb 6
class CardModifier(str, Enum):
    """Card-specific modifiers."""
    SIDE = "side"
    IMAGE_FULL = "image-full"
    COMPACT = "compact"

# %% ../../nbs/core/modifiers.ipynb 7
class InputModifier(str, Enum):
    """Input-specific modifiers."""
    BORDERED = "bordered"
    FLOATING = "floating"

# %% ../../nbs/core/modifiers.ipynb 8
@dataclass
class StyleModifier:
    """Represents a style modifier (outline, ghost, soft, etc.).
    
    Style modifiers change the visual appearance of a component
    while maintaining its core functionality.
    """
    name: str  # Modifier name (e.g., 'outline', 'ghost', 'soft')
    component: str  # Component this applies to (e.g., 'btn', 'badge')
    conflicts_with: List[str] = field(default_factory=list)  # Other styles this conflicts with
    description: Optional[str] = None  # Optional description
    
    def class_name(
        self
    ) -> str:  # TODO: Add return description
        """Return the full class name for this modifier."""
        return f"{self.component}-{self.name}"

# %% ../../nbs/core/modifiers.ipynb 10
class HasStyles:
    """Mixin for components with style variants.
    
    This mixin provides functionality for components that have
    different visual styles like outline, ghost, soft, etc.
    """
    
    style: Optional[str] = None
    
    @classmethod
    def styles(
        cls  # TODO: Add type hint and description
    ) -> Dict[str, StyleModifier]:  # TODO: Add return description
        """Return available style modifiers.
        
        Subclasses should override this to define their styles.
        """
        return {}
    
    def style_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Return style modifier classes."""
        if not self.style:
            return []
            
        styles = self.styles()
        if self.style not in styles:
            # If style is not predefined, assume it's a custom style class
            return [f"{self.component_class()}-{self.style}"]
            
        return [styles[self.style].class_name()]
    
    def has_conflicting_styles(
        self
    ) -> bool:  # TODO: Add return description
        """Check if the current style conflicts with others."""
        if not self.style:
            return False
            
        styles = self.styles()
        if self.style in styles:
            style_mod = styles[self.style]
            # Check if any other set styles conflict
            for other_style in styles:
                if other_style != self.style and hasattr(self, other_style):
                    if other_style in style_mod.conflicts_with:
                        return True
        return False
