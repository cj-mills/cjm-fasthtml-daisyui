"""Base classes and types for all daisyUI components"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/base.ipynb.

# %% auto 0
__all__ = ['deduplicate_classes', 'HasSize', 'DaisyComponent', 'ValidatedDaisyComponent']

# %% ../../nbs/core/base.ipynb 3
from typing import Dict, Any, Optional, List, Union, Literal
from dataclasses import dataclass, field
from enum import Enum
from fasthtml.common import *
from cjm_tailwind_utils.all import TailwindBuilder
from cjm_fasthtml_daisyui.core.types import (
    # Enums
    DaisyPosition,
    DaisyBreakpoint,
    DaisySize,
    SemanticColor,
    ColorUtility,
    DaisyComponentType,
    # Protocols
    CSSContributor,
    ComponentProtocol,
    FeatureSupport,
    # Utility functions
    ensure_list,
    ensure_dict
)
from cjm_fasthtml_daisyui.core.colors import (
    ColorBuilder, ColorMixin,
    apply_semantic_colors, get_color_classes
)

# %% ../../nbs/core/base.ipynb 4
def deduplicate_classes(
    *class_sources: Union[str, List[str], None] # Multiple sources of CSS classes (strings, lists, or None)
) -> str:  # Space-separated string of deduplicated CSS classes, sorted alphabetically
    """Deduplicate CSS classes from multiple sources.
    
    Takes multiple sources of CSS classes (strings, lists, or None values) and
    returns a single space-separated string with duplicates removed and sorted
    alphabetically for consistency.
    
    Args:
        *class_sources: Variable number of class sources, each can be:
            - A space-separated string of CSS classes
            - A list of CSS class strings
            - None (will be ignored)
    
    Returns:
        A space-separated string of unique CSS classes, sorted alphabetically
        
    Examples:
        >>> deduplicate_classes("btn btn-primary", ["btn", "btn-lg"])
        'btn btn-lg btn-primary'
        
        >>> deduplicate_classes("hidden md:block", None, ["hidden", "lg:block"])
        'hidden lg:block md:block'
    """
    all_classes = set()
    
    for source in class_sources:
        if source is None:
            continue
        elif isinstance(source, str):
            # Split space-separated string into individual classes
            all_classes.update(source.split())
        elif isinstance(source, list):
            # Add all items from the list
            all_classes.update(source)
        else:
            # For any other iterable, try to add its items
            try:
                all_classes.update(source)
            except TypeError:
                # If it's not iterable, convert to string and split
                all_classes.update(str(source).split())
    
    # Return sorted for consistent output
    return " ".join(sorted(all_classes))

# %% ../../nbs/core/base.ipynb 7
@dataclass 
class HasSize(CSSContributor):
    """Mixin for components that support size modifiers.
    
    This mixin provides size support for daisyUI components,
    including responsive size variations.
    
    Note: This mixin expects to be used with a class that has a
    component_class() method (like DaisyComponent).
    """
    
    # Size properties
    size: Optional[Union[DaisySize, str]] = None
    responsive_size: Optional[Dict[str, str]] = None  # e.g., {"md": "lg", "lg": "xl"}
    
    def get_css_classes(
        self
    ) -> List[str]:  # List of CSS class strings for size modifiers
        """Get size-related CSS classes.
        
        Returns:
            List of CSS class strings for size modifiers
        """
        classes: List[str] = []
        
        # Only add size classes if we have a component_class method
        if hasattr(self, 'component_class') and callable(self.component_class):
            try:
                base_class = self.component_class()
                
                # Add size modifier
                if self.size:
                    size_val = self.size.value if isinstance(self.size, DaisySize) else self.size
                    classes.append(f"{base_class}-{size_val}")
                
                # Add responsive size modifiers  
                if self.responsive_size:
                    for breakpoint, size in self.responsive_size.items():
                        classes.append(f"{breakpoint}:{base_class}-{size}")
            except:
                # If component_class raises an error, skip size classes
                pass
                
        return classes

# %% ../../nbs/core/base.ipynb 9
@dataclass
class DaisyComponent(ColorMixin, ComponentProtocol):
    """Base class for all daisyUI components.
    
    This class provides the foundation for building daisyUI components with:
    - Type-safe semantic color support with automatic content colors
    - Custom class and attribute support
    - Integration with cjm-tailwind-utils for additional styling
    - Responsive modifier support
    - Full implementation of ComponentProtocol interface
    """
    
    # HTML attributes
    id: Optional[str] = None
    cls: Optional[str] = None  # Additional custom classes
    attrs: Dict[str, Any] = field(default_factory=dict)
    
    # Responsive modifiers
    responsive_hide: Optional[List[str]] = None  # Breakpoints to hide at
    responsive_show: Optional[List[str]] = None  # Breakpoints to show at
    
    # Additional Tailwind customization
    tw_padding: Optional[Union[int, str]] = None
    tw_margin: Optional[Union[int, str]] = None
    tw_utilities: Optional[List[str]] = None  # Raw Tailwind utilities
    
    def component_class(
        self
    ) -> str:  # The base component class name (e.g., 'btn', 'card')
        """Return the base component class name (e.g., 'btn', 'card').
        
        Subclasses must implement this method.
        """
        raise NotImplementedError("Subclasses must implement component_class()")
    
    def modifier_classes(
        self
    ) -> List[str]:  # List of modifier CSS classes
        """Return all modifier classes for this component."""
        # Subclasses should override this to add their specific modifiers
        return []
    
    def build_classes(
        self
    ) -> str:  # Space-separated string of all CSS classes
        """Build complete class string with deduplication."""
        # Collect all classes from different sources
        class_sources = []
        
        # Add component classes
        class_sources.append(self.component_class())
        class_sources.extend(self.modifier_classes())
        
        # Add padding/margin
        tb = TailwindBuilder()
        if self.tw_padding is not None:
            tb.p(self.tw_padding)
        if self.tw_margin is not None:
            tb.m(self.tw_margin)
        
        # Get padding/margin classes from TailwindBuilder
        if tb.build():
            class_sources.extend(ensure_list(tb.build()))
            
        # Add responsive visibility
        responsive_classes = []
        if self.responsive_hide:
            for bp in self.responsive_hide:
                responsive_classes.append(f"{bp}:hidden")
        if self.responsive_show:
            for bp in self.responsive_show:
                responsive_classes.append(f"{bp}:block")
        class_sources.extend(responsive_classes)
                
        # Add raw utilities
        if self.tw_utilities:
            class_sources.extend(self.tw_utilities)
            
        # Collect CSS classes from all mixins that implement get_css_classes
        # Track which actual methods we've called to avoid duplicates
        called_methods = set()
        
        # Check each class in the MRO for get_css_classes method
        for cls in type(self).__mro__:
            if hasattr(cls, 'get_css_classes'):
                method = getattr(cls, 'get_css_classes')
                # Check if this is a unique method (not inherited)
                method_id = id(method.__func__ if hasattr(method, '__func__') else method)
                if callable(method) and method_id not in called_methods:
                    try:
                        result = method(self)
                        if result:
                            class_sources.extend(result)
                        called_methods.add(method_id)
                    except:
                        pass
        
        # Add custom classes last
        if self.cls:
            class_sources.extend(ensure_list(self.cls))
            
        # Use the deduplicate_classes function to build the final class string
        return deduplicate_classes(*class_sources)
    
    def render_attrs(
        self
    ) -> Dict[str, Any]:  # Dictionary of HTML attributes
        """Build all HTML attributes for rendering."""
        attrs: Dict[str, Any] = {**self.attrs}
        attrs["class"] = self.build_classes()
        
        if self.id:
            attrs["id"] = self.id
            
        return attrs
        
    def with_utilities(
        self,
        *utilities: str # Tailwind utility classes to add
    ) -> 'DaisyComponent':  # Self for method chaining
        """Add Tailwind utilities and return self for chaining."""
        if self.tw_utilities is None:
            self.tw_utilities = []
        self.tw_utilities.extend(utilities)
        return self
    
    def with_semantic_colors(
        self,
        bg: Optional[Union[SemanticColor, str]] = None, # Background color
        text: Optional[Union[SemanticColor, str]] = None, # Text color (auto-selected if None and auto_content=True)
        border: Optional[Union[SemanticColor, str]] = None, # Border color
        auto_content: bool = True  # Automatically select appropriate text color for background
    ) -> 'DaisyComponent':  # Self for method chaining
        """Apply semantic colors with automatic content color selection."""
        classes = ensure_list(apply_semantic_colors(bg, text, border, auto_content))
        return self.with_utilities(*classes)

# %% ../../nbs/core/base.ipynb 11
@dataclass
class ValidatedDaisyComponent(DaisyComponent):
    """Extended base class with component type validation.
    
    This optional base class adds validation to ensure component classes
    match known daisyUI component types.
    """
    
    # Component type for validation
    component_type: Optional[DaisyComponentType] = None
    
    def component_class(
        self
    ) -> str:  # The base component class name with validation
        """Return the base component class name with validation.
        
        If component_type is set, returns its value.
        Otherwise falls back to the standard implementation.
        """
        if self.component_type:
            return self.component_type.value
        return super().component_class()
    
    def validate_component_type(
        self
    ) -> None: # Validates component type if specified
        """Validate component type if specified.
        
        This should be called by subclasses after they've set up
        their component_type and implemented component_class.
        """
        if self.component_type:
            # For validation, temporarily clear component_type to get the actual class
            temp_type = self.component_type
            self.component_type = None
            try:
                actual = self.component_class()
            except NotImplementedError:
                # If component_class is not implemented yet, skip validation
                actual = None
            finally:
                self.component_type = temp_type
                
            if actual and actual != self.component_type.value:
                raise ValueError(
                    f"Component class mismatch: expected '{self.component_type.value}' "
                    f"but got '{actual}' for {self.component_type.name}"
                )
