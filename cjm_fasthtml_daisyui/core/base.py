"""Base classes and types for all daisyUI components"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/base.ipynb.

# %% auto 0
__all__ = ['DaisyGlass', 'DaisyPosition', 'DaisyAlign', 'DaisyBreakpoint', 'DaisySize', 'DaisyComponent']

# %% ../../nbs/core/base.ipynb 3
from typing import Dict, Any, Optional, List, Union, Literal
from dataclasses import dataclass, field
from enum import Enum
from fasthtml.common import *
from cjm_tailwind_utils.core import tw
from cjm_fasthtml_daisyui.core.colors import (
    SemanticColor, ColorUtility, ColorBuilder, ColorMixin,
    apply_semantic_colors, get_color_classes
)

# %% ../../nbs/core/base.ipynb 5
# DaisyColor has been replaced by SemanticColor from cjm_fasthtml_daisyui.core.colors
# which provides more comprehensive color support including content colors

# %% ../../nbs/core/base.ipynb 6
class DaisyGlass(str, Enum):
    """Glass effect modifier."""
    GLASS = "glass"

# %% ../../nbs/core/base.ipynb 7
class DaisyPosition(str, Enum):
    """Common position values."""
    TOP = "top"
    BOTTOM = "bottom"
    LEFT = "left"
    RIGHT = "right"
    START = "start"
    CENTER = "center"
    END = "end"
    MIDDLE = "middle"

# %% ../../nbs/core/base.ipynb 8
class DaisyAlign(str, Enum):
    """Alignment values for components."""
    START = "start"
    CENTER = "center"
    END = "end"

# %% ../../nbs/core/base.ipynb 9
class DaisyBreakpoint(str, Enum):
    """Responsive breakpoints."""
    SM = "sm"
    MD = "md"
    LG = "lg"
    XL = "xl"
    XXL = "2xl"

# %% ../../nbs/core/base.ipynb 10
class DaisySize(str, Enum):
    """Common size variants across components."""
    XS = "xs"
    SM = "sm"
    MD = "md"
    LG = "lg"
    XL = "xl"

# %% ../../nbs/core/base.ipynb 12
@dataclass
class DaisyComponent(ColorMixin):
    """Base class for all daisyUI components.
    
    This class provides the foundation for building daisyUI components with:
    - Type-safe semantic color support with automatic content colors
    - Custom class and attribute support
    - Integration with cjm-tailwind-utils for additional styling
    - Responsive modifier support
    """
    
    # HTML attributes
    id: Optional[str] = None
    cls: Optional[str] = None  # Additional custom classes
    attrs: Dict[str, Any] = field(default_factory=dict)
    
    # Common modifiers
    color: Optional[Union[SemanticColor, str]] = None
    size: Optional[Union[DaisySize, str]] = None
    glass: bool = False  # Glass effect modifier
    
    # Responsive modifiers (e.g., {"md": "lg", "lg": "xl"} for responsive sizes)
    responsive_size: Optional[Dict[str, str]] = None
    responsive_hide: Optional[List[str]] = None  # Breakpoints to hide at
    responsive_show: Optional[List[str]] = None  # Breakpoints to show at
    
    # Additional Tailwind customization
    tw_padding: Optional[Union[int, str]] = None
    tw_margin: Optional[Union[int, str]] = None
    tw_utilities: Optional[List[str]] = None  # Raw Tailwind utilities
    
    def component_class(
        self
    ) -> str:  # TODO: Add return description
        """Return the base component class name (e.g., 'btn', 'card')."""
        raise NotImplementedError("Subclasses must implement component_class()")
    
    def modifier_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Return all modifier classes for this component."""
        classes = []
        
        # Add color modifier if applicable
        if self.color and self.supports_color():
            color_val = self.color.value if isinstance(self.color, SemanticColor) else self.color
            classes.append(f"{self.component_class()}-{color_val}")
            
        # Add size modifier if applicable
        if self.size and self.supports_size():
            size_val = self.size.value if isinstance(self.size, DaisySize) else self.size
            classes.append(f"{self.component_class()}-{size_val}")
            
        # Add glass modifier
        if self.glass and self.supports_glass():
            classes.append("glass")
            
        # Add responsive size modifiers
        if self.responsive_size and self.supports_size():
            for breakpoint, size in self.responsive_size.items():
                classes.append(f"{breakpoint}:{self.component_class()}-{size}")
                
        return classes
    
    def supports_color(
        self
    ) -> bool:  # TODO: Add return description
        """Whether this component supports color modifiers."""
        return False
    
    def supports_size(
        self
    ) -> bool:  # TODO: Add return description
        """Whether this component supports size modifiers."""
        return False
        
    def supports_glass(
        self
    ) -> bool:  # TODO: Add return description
        """Whether this component supports glass effect."""
        return False
    
    def build_classes(
        self
    ) -> str:  # TODO: Add return description
        """Build complete class string with deduplication."""
        classes = [self.component_class()]
        classes.extend(self.modifier_classes())
        
        # Build Tailwind utility classes
        tw_classes = []
        
        # Add padding/margin
        if self.tw_padding is not None:
            tw_classes.append(tw.p(self.tw_padding))
        if self.tw_margin is not None:
            tw_classes.append(tw.m(self.tw_margin))
            
        # Add responsive visibility
        if self.responsive_hide:
            for bp in self.responsive_hide:
                tw_classes.append(f"{bp}:hidden")
        if self.responsive_show:
            for bp in self.responsive_show:
                tw_classes.append(f"{bp}:block")
                
        # Add raw utilities
        if self.tw_utilities:
            tw_classes.extend(self.tw_utilities)
            
        # Add color mixin classes
        color_classes = self.get_color_classes()
        if color_classes:
            tw_classes.extend(color_classes)
        
        # Merge all classes
        all_classes = [" ".join(classes)]
        if tw_classes:
            all_classes.extend(tw_classes)
        if self.cls:
            all_classes.append(self.cls)
            
        # Use tw.merge for proper deduplication
        return tw.merge(*all_classes)
    
    def render_attrs(
        self
    ) -> Dict[str, Any]:  # TODO: Add return description
        """Build all HTML attributes for rendering."""
        attrs = {**self.attrs}
        attrs["class"] = self.build_classes()
        
        if self.id:
            attrs["id"] = self.id
            
        return attrs
        
    def with_utilities(
        self,
        *utilities: str
    ) -> 'DaisyComponent':  # TODO: Add return description
        """Add Tailwind utilities and return self for chaining."""
        if self.tw_utilities is None:
            self.tw_utilities = []
        self.tw_utilities.extend(utilities)
        return self
    
    def with_semantic_colors(
        self,
        bg: Optional[Union[SemanticColor, str]] = None,
        text: Optional[Union[SemanticColor, str]] = None,
        border: Optional[Union[SemanticColor, str]] = None,
        auto_content: bool = True  # TODO: Add description
    ) -> 'DaisyComponent':  # TODO: Add return description
        """Apply semantic colors with automatic content color selection.
        
        Args:
            bg: Background color
            text: Text color (auto-selected if None and auto_content=True)
            border: Border color  
            auto_content: Automatically select appropriate text color for background
            
        Returns:
            Self for method chaining
        """
        classes = apply_semantic_colors(bg, text, border, auto_content).split()
        return self.with_utilities(*classes)
