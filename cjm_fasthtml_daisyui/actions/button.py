"""[Buttons](https://daisyui.com/components/button/) allow the user to take actions or make choices."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/actions/button.ipynb.

# %% auto 0
__all__ = ['ButtonShape', 'Btn', 'ButtonGroup']

# %% ../../nbs/actions/button.ipynb 3
from typing import Optional, Union, List, Any, Literal
from enum import Enum
from dataclasses import dataclass, field
from fasthtml.common import *
from cjm_tailwind_utils.all import TailwindBuilder
from ..core.base import DaisyComponent, DaisySize
from cjm_fasthtml_daisyui.core.colors import (
    SemanticColor, ColorUtility, ColorBuilder, apply_semantic_colors
)
from ..core.behaviors import InteractiveMixin, FormControlMixin
from ..core.modifiers import StyleType, HasStyles
from ..core.htmx import HTMXComponent, HTMXAttrs

# %% ../../nbs/actions/button.ipynb 5
class ButtonShape(str, Enum):
    """Button shape modifiers"""
    DEFAULT = ""
    WIDE = "wide"      # Extra horizontal padding
    BLOCK = "block"    # Full width button
    SQUARE = "square"  # Square button (equal width/height)
    CIRCLE = "circle"  # Circular button

# %% ../../nbs/actions/button.ipynb 6
@dataclass
class Btn(HTMXComponent, HasStyles, InteractiveMixin, FormControlMixin):
    """
    daisyUI Button component with full feature support.
    
    Supports all button variants, styles, sizes, shapes, and states.
    Can be used as a regular button, submit button, or link button.
    
    Examples:
        Basic button:
            Btn("Click me", color=SemanticColor.PRIMARY)
        
        Icon button:
            Btn(Icon("heart"), shape=ButtonShape.CIRCLE, style=StyleType.GHOST)
        
        Loading button:
            Btn("Submit", loading=True, disabled=True)
    """
    
    # Content
    children: List[Any] = field(default_factory=list)
    
    # Button specific
    shape: Optional[ButtonShape] = None
    no_animation: bool = False  # Disable click animation
    
    # Icon support
    icon_start: Optional[FT] = None
    icon_end: Optional[FT] = None
    
    # Link button support
    href: Optional[str] = None
    target: Optional[str] = None
    
    # Form button properties
    type: Optional[str] = None
    form: Optional[str] = None
    
    def __init__(self, *children, **kwargs):
        "TODO: Add function description"
        # Extract children from args
        self.children = list(children)
        
        # Extract button-specific attributes before parent init
        self.icon_start = kwargs.pop('icon_start', None)
        self.icon_end = kwargs.pop('icon_end', None)
        self.shape = kwargs.pop('shape', None)
        self.no_animation = kwargs.pop('no_animation', False)
        self.href = kwargs.pop('href', None)
        self.target = kwargs.pop('target', None)
        
        # Extract style for HasStyles mixin
        self.style = kwargs.pop('style', None)
        
        # Extract InteractiveMixin properties
        self.active = kwargs.pop('active', False)
        self.disabled = kwargs.pop('disabled', False)
        self.loading = kwargs.pop('loading', False)
        self.open = kwargs.pop('open', False)
        self.checked = kwargs.pop('checked', False)
        self.focus = kwargs.pop('focus', False)
        self.hover = kwargs.pop('hover', False)
        
        # Extract FormControlMixin properties
        self.name = kwargs.pop('name', None)
        self.value = kwargs.pop('value', None)
        self.placeholder = kwargs.pop('placeholder', None)
        self.required = kwargs.pop('required', False)
        self.readonly = kwargs.pop('readonly', False)
        self.autofocus = kwargs.pop('autofocus', False)
        self.type = kwargs.pop('type', None)
        self.form = kwargs.pop('form', None)
        
        # Initialize parent classes
        super().__init__(**kwargs)
    
    def component_class(
        self
    ) -> str:  # TODO: Add return description
        "TODO: Add function description"
        return "btn"
    
    def supports_color(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def supports_size(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def supports_glass(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def supports_active(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def supports_disabled(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def supports_loading(
        self
    ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
        return True
    
    def get_style_modifiers(
        self
    ) -> List[StyleType]:  # TODO: Add return description
        """Get applicable style modifiers"""
        return [StyleType]
    
    def modifier_classes(
        self
    ) -> List[str]:  # TODO: Add return description
        """Build all modifier classes"""
        classes = super().modifier_classes()
        
        # Add style modifier
        if self.style:
            classes.append(f"btn-{self.style.value}")
        
        # Add shape modifier
        if self.shape and self.shape != ButtonShape.DEFAULT:
            classes.append(f"btn-{self.shape.value}")
        
        # Add behavior classes from InteractiveMixin
        classes.extend(self.behavior_classes())
        
        # Add no-animation
        if self.no_animation:
            classes.append("no-animation")
        
        return classes
    
    def render_content(
        self
    ) -> List[FT]:  # TODO: Add return description
        """Render button content with icons"""
        content = []
        
        # Add start icon
        if self.icon_start:
            content.append(self.icon_start)
        
        # Add main content
        content.extend(self.children)
        
        # Add loading spinner if needed
        if self.loading:
            content.append(Span(cls="loading loading-spinner"))
        
        # Add end icon
        if self.icon_end:
            content.append(self.icon_end)
        
        return content
    
    def render_attrs(
        self
    ) -> Dict[str, Any]:  # TODO: Add return description
        """Build all HTML attributes including form and behavior attrs."""
        attrs = super().render_attrs()
        
        # Add behavior attributes
        attrs.update(self.behavior_attrs())
        
        # Add form attributes
        if hasattr(self, 'form_attrs'):
            attrs.update(self.form_attrs())
        
        return attrs
    
    def render(
        self
    ) -> FT:  # TODO: Add return description
        """Render the button element"""
        attrs = self.render_attrs()
        content = self.render_content()
        
        # Determine element type
        if self.href:
            # Link button
            attrs['href'] = self.href
            if self.target:
                attrs['target'] = self.target
            if self.disabled:
                attrs['tabindex'] = '-1'
                attrs['role'] = 'button'
                attrs['aria-disabled'] = 'true'
            return A(*content, **attrs)
        else:
            # Regular or form button
            if self.type:
                attrs['type'] = self.type
            else:
                attrs['type'] = 'button'  # Default to prevent form submission
                
            if self.name:
                attrs['name'] = self.name
            if self.value:
                attrs['value'] = self.value
            if self.form:
                attrs['form'] = self.form
                
            # Use FastHTML's Button element
            return Button(*content, **attrs)
    
    # Convenience methods for common patterns
    @classmethod
    def primary(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a primary button"""
        return cls(*children, color=SemanticColor.PRIMARY, **kwargs)
    
    @classmethod
    def secondary(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a secondary button"""
        return cls(*children, color=SemanticColor.SECONDARY, **kwargs)
    
    @classmethod
    def accent(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create an accent button"""
        return cls(*children, color=SemanticColor.ACCENT, **kwargs)
    
    @classmethod
    def success(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a success button"""
        return cls(*children, color=SemanticColor.SUCCESS, **kwargs)
    
    @classmethod
    def error(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create an error/danger button"""
        return cls(*children, color=SemanticColor.ERROR, **kwargs)
    
    @classmethod
    def warning(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a warning button"""
        return cls(*children, color=SemanticColor.WARNING, **kwargs)
    
    @classmethod
    def info(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create an info button"""
        return cls(*children, color=SemanticColor.INFO, **kwargs)
    
    @classmethod
    def ghost(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a ghost button"""
        kwargs['style'] = StyleType.GHOST
        return cls(*children, **kwargs)
    
    @classmethod
    def link(
        cls,  # TODO: Add type hint and description
        *children,
        href: str,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a link-styled button"""
        kwargs['style'] = StyleType.LINK
        kwargs['href'] = href
        return cls(*children, **kwargs)
    
    @classmethod
    def outline(
        cls,  # TODO: Add type hint and description
        *children,
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create an outline button"""
        kwargs['style'] = StyleType.OUTLINE
        return cls(*children, **kwargs)
    
    @classmethod
    def icon(
        cls,  # TODO: Add type hint and description
        icon: FT,  # TODO: Add description
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create an icon-only button (typically square or circle)"""
        kwargs.setdefault('shape', ButtonShape.SQUARE)
        return cls(icon, **kwargs)
    
    @classmethod
    def submit(
        cls,  # TODO: Add type hint and description
        text: str = "Submit",  # TODO: Add description
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a submit button"""
        return cls(text, type="submit", color=SemanticColor.PRIMARY, **kwargs)
    
    @classmethod
    def cancel(
        cls,  # TODO: Add type hint and description
        text: str = "Cancel",  # TODO: Add description
        **kwargs
    ) -> 'Btn':  # TODO: Add return description
        """Create a cancel button"""
        kwargs['style'] = StyleType.GHOST
        return cls(text, **kwargs)

# %% ../../nbs/actions/button.ipynb 8
@dataclass
class ButtonGroup:
    """Helper class for creating button groups"""
    
    @staticmethod
    def actions(
        *buttons: Btn,
        justify: str = "end"
    ) -> FT:  # TODO: Add return description
        """Create an actions button group (commonly used in cards/modals)"""
        justify_map = {
            "start": "start",
            "center": "center", 
            "end": "end",
            "between": "between",
            "around": "around"
        }
        
        tb = TailwindBuilder()
        tb.flex().gap(2).justify(justify_map.get(justify, "end"))
        
        return Div(*buttons, cls=tb.build())
    
    @staticmethod
    def toolbar(
        *buttons: Btn,
        vertical: bool = False
    ) -> FT:  # TODO: Add return description
        """Create a toolbar-style button group"""
        tb = TailwindBuilder()
        if vertical:
            tb.add_class("join join-vertical")
        else:
            tb.add_class("join join-horizontal")
            
        return Div(
            *buttons,
            cls=tb.build()
        )
    
    @staticmethod
    def pagination(
        current: int,  # TODO: Add description
        total: int,  # TODO: Add description
        on_page: Optional[str] = None,  # TODO: Add description
        size: DaisySize = DaisySize.MD  # TODO: Add description
    ) -> FT:  # TODO: Add return description
        """Create a pagination button group"""
        buttons = []
        
        # Previous button
        prev_btn = Btn(
            "«", 
            size=size,
            disabled=(current <= 1),
            cls="join-item"
        )
        if on_page and current > 1:
            prev_btn.htmx = HTMXAttrs(hx_get=f"{on_page}?page={current-1}")
        buttons.append(prev_btn)
        
        # Page numbers (simplified - show current and neighbors)
        for page in range(max(1, current-2), min(total+1, current+3)):
            btn = Btn(
                str(page),
                size=size,
                active=(page == current),
                cls="join-item"
            )
            if on_page and page != current:
                btn.htmx = HTMXAttrs(hx_get=f"{on_page}?page={page}")
            buttons.append(btn)
        
        # Next button
        next_btn = Btn(
            "»",
            size=size, 
            disabled=(current >= total),
            cls="join-item"
        )
        if on_page and current < total:
            next_btn.htmx = HTMXAttrs(hx_get=f"{on_page}?page={current+1}")
        buttons.append(next_btn)
        
        return Div(*[btn.render() for btn in buttons], cls="join")
