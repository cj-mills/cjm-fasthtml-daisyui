# cjm-fasthtml-daisyui


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

> Python-native UI components for FastHTML using daisyUI v5 and Tailwind
> CSS v4

A fully Python-abstracted UI component library that provides reusable
components built with [Tailwind CSS
v4](https://tailwindcss.com/blog/tailwindcss-v4) (abstracted through the
[`cjm-tailwind-utils`](https://cj-mills.github.io/cjm-tailwind-utils/)
library) and [daisyUI v5](https://daisyui.com/docs/v5/) for
[FastHTML](https://www.fastht.ml/docs/) projects.

## Install

``` bash
pip install cjm-fasthtml-daisyui
```

## Project Structure

    nbs/
    ├── actions/ (1)
    │   └── button.ipynb  # Buttons allow the user to take actions or make choices.
    └── core/ (12)
        ├── base.ipynb       # Base classes and types for all daisyUI components
        ├── behaviors.ipynb  # Mixin for components with behavior states (active, disabled, loading)
        ├── colors.ipynb     # Semantic color system for daisyUI components
        ├── config.ipynb     # daisyUI configuration management for FastHTML projects
        ├── elements.ipynb   # HTML element creation utilities
        ├── htmx.ipynb       # HTMX patterns and helpers for daisyUI components in FastHTML
        ├── parts.ipynb      # System for handling component parts (e.g., card-body, modal-box)
        ├── placement.ipynb  # Mixins for component placement and direction options
        ├── resources.ipynb  # Managing daisyUI and Tailwind CSS resources for FastHTML projects
        ├── testing.ipynb    # Standardized testing framework for daisyUI components in Jupyter notebooks
        ├── types.ipynb      # Protocols, enums, type aliases, and utilities for type-safe daisyUI component development
        └── variants.ipynb   # System for handling component variants and states

Total: 13 notebooks across 2 directories

## Module Dependencies

``` mermaid
graph LR
    actions_button[actions.button<br/>Button]
    core_base[core.base<br/>Core Base Classes]
    core_behaviors[core.behaviors<br/>Behavior States]
    core_colors[core.colors<br/>Colors]
    core_config[core.config<br/>Configuration]
    core_elements[core.elements<br/>Elements]
    core_htmx[core.htmx<br/>HTMX Integration]
    core_parts[core.parts<br/>Component Parts]
    core_placement[core.placement<br/>Placement & Direction]
    core_resources[core.resources<br/>Resources]
    core_testing[core.testing<br/>Testing]
    core_types[core.types<br/>Types]
    core_variants[core.variants<br/>Variant System]

    actions_button --> core_testing
    actions_button --> core_htmx
    actions_button --> core_config
    actions_button --> core_types
    actions_button --> core_variants
    actions_button --> core_colors
    actions_button --> core_base
    actions_button --> core_behaviors
    core_base --> core_colors
    core_base --> core_types
    core_behaviors --> core_types
    core_colors --> core_types
    core_config --> core_types
    core_htmx --> core_types
    core_htmx --> core_base
    core_parts --> core_types
    core_parts --> core_elements
    core_placement --> core_types
    core_resources --> core_types
    core_testing --> core_types
    core_testing --> core_resources
    core_testing --> core_colors
    core_testing --> core_config
    core_variants --> core_types
```

*24 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Core Base Classes (`base.ipynb`)

> Base classes and types for all daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.base import (
    HasSize,
    DaisyComponent,
    ValidatedDaisyComponent
)
```

#### Classes

``` python
@dataclass
class HasSize(CSSContributor):
    """
    Mixin for components that support size modifiers.
    
    This mixin provides size support for daisyUI components,
    including responsive size variations.
    
    Note: This mixin expects to be used with a class that has a
    component_class() method (like DaisyComponent).
    """
    
    size: Optional[Union[DaisySize, str]]
    responsive_size: Optional[ResponsiveDict]  # e.g., {"md": "lg", "lg": "xl"}
    
    def get_css_classes(self) -> CSSClasses:
            """Get size-related CSS classes.
            
            Returns:
                List of CSS class strings for size modifiers
            """
            classes: CSSClasses = []
        "Get size-related CSS classes.

Returns:
    List of CSS class strings for size modifiers"
```

``` python
@dataclass
class DaisyComponent(ColorMixin, ComponentProtocol):
    """
    Base class for all daisyUI components.
    
    This class provides the foundation for building daisyUI components with:
    - Type-safe semantic color support with automatic content colors
    - Custom class and attribute support
    - Integration with cjm-tailwind-utils for additional styling
    - Responsive modifier support
    - Full implementation of ComponentProtocol interface
    """
    
    id: Optional[str]
    cls: Optional[str]  # Additional custom classes
    attrs: HTMLAttrs = field(...)
    responsive_hide: Optional[List[str]]  # Breakpoints to hide at
    responsive_show: Optional[List[str]]  # Breakpoints to show at
    tw_padding: Optional[Union[int, str]]
    tw_margin: Optional[Union[int, str]]
    tw_utilities: Optional[CSSClasses]  # Raw Tailwind utilities
    
    def component_class(self) -> str:
            """Return the base component class name (e.g., 'btn', 'card').
            
            Subclasses must implement this method.
            """
            raise NotImplementedError("Subclasses must implement component_class()")
        
        def modifier_classes(self) -> CSSClasses
        "Return the base component class name (e.g., 'btn', 'card').

Subclasses must implement this method."
    
    def modifier_classes(self) -> CSSClasses:
            """Return all modifier classes for this component.
            
            Returns:
                List of modifier CSS classes
            """
            # Subclasses should override this to add their specific modifiers
            return []
        
        def build_classes(self) -> str
        "Return all modifier classes for this component.

Returns:
    List of modifier CSS classes"
    
    def build_classes(self) -> str:
            """Build complete class string with deduplication.
            
            Returns:
                Space-separated string of all CSS classes
            """
            # Use a set to collect all unique classes
            all_classes = set()
            
            # Add component classes
            all_classes.add(self.component_class())
            all_classes.update(self.modifier_classes())
            
            # Add padding/margin
            tb = TailwindBuilder()
            if self.tw_padding is not None
        "Build complete class string with deduplication.

Returns:
    Space-separated string of all CSS classes"
    
    def render_attrs(self) -> HTMLAttrs:
            """Build all HTML attributes for rendering.
            
            Returns:
                Dictionary of HTML attributes
            """
            attrs: HTMLAttrs = {**self.attrs}
        "Build all HTML attributes for rendering.

Returns:
    Dictionary of HTML attributes"
    
    def with_utilities(
            self,
            *utilities: str
        ) -> 'DaisyComponent'
        "Add Tailwind utilities and return self for chaining.

Args:
    *utilities: Tailwind utility classes to add
    
Returns:
    Self for method chaining"
    
    def with_semantic_colors(
            self,
            bg: Optional[Union[SemanticColor, str]] = None,
            text: Optional[Union[SemanticColor, str]] = None,
            border: Optional[Union[SemanticColor, str]] = None,
            auto_content: bool = True
        ) -> 'DaisyComponent'
        "Apply semantic colors with automatic content color selection.

Args:
    bg: Background color
    text: Text color (auto-selected if None and auto_content=True)
    border: Border color  
    auto_content: Automatically select appropriate text color for background
    
Returns:
    Self for method chaining"
```

``` python
@dataclass
class ValidatedDaisyComponent(DaisyComponent):
    """
    Extended base class with component type validation.
    
    This optional base class adds validation to ensure component classes
    match known daisyUI component types.
    """
    
    component_type: Optional[DaisyComponentType]
    
    def component_class(self) -> str:
            """Return the base component class name with validation.
            
            If component_type is set, returns its value.
            Otherwise falls back to the standard implementation.
            """
            if self.component_type
        "Return the base component class name with validation.

If component_type is set, returns its value.
Otherwise falls back to the standard implementation."
    
    def validate_component_type(self):
            """Validate component type if specified.
            
            This should be called by subclasses after they've set up
            their component_type and implemented component_class.
            """
            if self.component_type
        "Validate component type if specified.

This should be called by subclasses after they've set up
their component_type and implemented component_class."
```

### Behavior States (`behaviors.ipynb`)

> Mixin for components with behavior states (active, disabled, loading)

#### Import

``` python
from cjm_fasthtml_daisyui.core.behaviors import (
    HasBehaviors,
    InteractiveMixin,
    FormControlMixin
)
```

#### Classes

``` python
class HasBehaviors(CSSContributor):
    """
    Mixin for components with behavior states.
    
    This mixin provides functionality for interactive components
    that can be active, disabled, loading, etc.
    
    Note: This mixin assumes it will be used with classes that provide
    a `component_class()` method (typically components implementing ComponentProtocol).
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get behavior state classes.
            
            Returns:
                List of CSS class strings for behavior states
            """
            classes = []
            base = self.component_class()
            
            if self.active and self.supports_active()
        "Get behavior state classes.

Returns:
    List of CSS class strings for behavior states"
    
    def supports_active(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports active state."
    
    def supports_disabled(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports disabled state."
    
    def supports_loading(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports loading state."
    
    def loading_uses_base_class(
            self
        ) -> bool:  # TODO: Add return description
        "Whether loading state uses 'loading' instead of '{component}-loading'."
    
    def behavior_attrs(
            self
        ) -> HTMLAttrs:  # TODO: Add return description
        "Return HTML attributes for behavior states."
```

``` python
class InteractiveMixin(HasBehaviors):
    """
    Extended mixin for interactive components.
    
    This combines HasBehaviors with additional interactive properties
    commonly needed for buttons, inputs, and other interactive elements.
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get all interactive state classes.
            
            Returns:
                List of CSS class strings for interactive states
            """
            classes = super().get_css_classes()
            base = self.component_class()
            
            if self.focus and hasattr(self, 'supports_focus') and self.supports_focus()
        "Get all interactive state classes.

Returns:
    List of CSS class strings for interactive states"
```

``` python
class FormControlMixin:
    """
    Mixin for form control components.
    
    This mixin provides common properties and methods for
    form elements like inputs, selects, textareas, etc.
    """
    
    def form_attrs(
            self
        ) -> HTMLAttrs:  # TODO: Add return description
        "Return form-related HTML attributes."
```

### Button (`button.ipynb`)

> [Buttons](https://daisyui.com/components/button/) allow the user to
> take actions or make choices.

#### Import

``` python
from cjm_fasthtml_daisyui.actions.button import (
    ButtonShape,
    Btn
)
```

#### Classes

``` python
class ButtonShape(str, Enum):
    "Button shape modifiers"
```

``` python
@dataclass
class Btn:
    def __init__(self, *children, **kwargs)
    """
    daisyUI Button component with full feature support.
    
    Supports all button variants, styles, sizes, shapes, and states.
    Can be used as a regular button, submit button, or link button.
    
    Examples:
        Basic button:
            Btn("Click me", color=SemanticColor.PRIMARY)
        
        Icon button:
            Btn(Icon("heart"), shape=ButtonShape.CIRCLE, style=StyleType.GHOST)
        
        Loading button:
            Btn("Submit", loading=True, disabled=True)
    """
    
    children: Children = field(...)
    color: Optional[Union[SemanticColor, str]]
    shape: Optional[ButtonShape]
    no_animation: bool = False  # Disable click animation
    icon_start: Optional[FT]
    icon_end: Optional[FT]
    href: Optional[str]
    target: Optional[str]
    type: Optional[str]
    form: Optional[str]
    style: Optional[Union[StyleType, str]]
    
    def __init__(self, *children, **kwargs)
        "Initialize button with children and properties."
    
    def variants(cls) -> Dict[str, Any]:
            """Define available variants for buttons.
            
            Returns:
                Dictionary of variant definitions
            """
            return {
                "style": create_style_variant("btn")
        "Define available variants for buttons.

Returns:
    Dictionary of variant definitions"
    
    def component_class(self) -> str:
            """Return the base component class name."""
            return DaisyComponentType.BUTTON.value
        
        def modifier_classes(self) -> CSSClasses
        "Return the base component class name."
    
    def modifier_classes(self) -> CSSClasses:
            """Build all modifier classes.
            
            Returns:
                List of modifier CSS classes
            """
            classes = super().modifier_classes()
            
            # Add component-specific color modifier
            if self.color
        "Build all modifier classes.

Returns:
    List of modifier CSS classes"
    
    def render_content(self) -> Children:
            """Render button content with icons.
            
            Returns:
                List of FastHTML elements
            """
            content: Children = []
        "Render button content with icons.

Returns:
    List of FastHTML elements"
    
    def render_attrs(self) -> HTMLAttrs:
            """Build all HTML attributes including form and behavior attrs.
            
            Returns:
                Dictionary of HTML attributes
            """
            attrs = super().render_attrs()
            
            # Add behavior attributes
            attrs.update(self.behavior_attrs())
            
            # Add form attributes
            if hasattr(self, 'form_attrs')
        "Build all HTML attributes including form and behavior attrs.

Returns:
    Dictionary of HTML attributes"
    
    def render(self) -> FT:
            """Render the button element.
            
            Returns:
                FastHTML element (Button or A)
            """
            attrs = self.render_attrs()
            content = self.render_content()
            
            # Determine element type
            if self.href
        "Render the button element.

Returns:
    FastHTML element (Button or A)"
    
    def primary(cls, *children, **kwargs) -> 'Btn':
            """Create a primary button."""
            return cls(*children, color=SemanticColor.PRIMARY, **kwargs)
        
        @classmethod
        def secondary(cls, *children, **kwargs) -> 'Btn'
        "Create a primary button."
    
    def secondary(cls, *children, **kwargs) -> 'Btn':
            """Create a secondary button."""
            return cls(*children, color=SemanticColor.SECONDARY, **kwargs)
        
        @classmethod
        def accent(cls, *children, **kwargs) -> 'Btn'
        "Create a secondary button."
    
    def accent(cls, *children, **kwargs) -> 'Btn':
            """Create an accent button."""
            return cls(*children, color=SemanticColor.ACCENT, **kwargs)
        
        @classmethod
        def success(cls, *children, **kwargs) -> 'Btn'
        "Create an accent button."
    
    def success(cls, *children, **kwargs) -> 'Btn':
            """Create a success button."""
            return cls(*children, color=SemanticColor.SUCCESS, **kwargs)
        
        @classmethod
        def error(cls, *children, **kwargs) -> 'Btn'
        "Create a success button."
    
    def error(cls, *children, **kwargs) -> 'Btn':
            """Create an error/danger button."""
            return cls(*children, color=SemanticColor.ERROR, **kwargs)
        
        @classmethod
        def warning(cls, *children, **kwargs) -> 'Btn'
        "Create an error/danger button."
    
    def warning(cls, *children, **kwargs) -> 'Btn':
            """Create a warning button."""
            return cls(*children, color=SemanticColor.WARNING, **kwargs)
        
        @classmethod
        def info(cls, *children, **kwargs) -> 'Btn'
        "Create a warning button."
    
    def info(cls, *children, **kwargs) -> 'Btn':
            """Create an info button."""
            return cls(*children, color=SemanticColor.INFO, **kwargs)
        
        @classmethod
        def ghost(cls, *children, **kwargs) -> 'Btn'
        "Create an info button."
    
    def ghost(cls, *children, **kwargs) -> 'Btn':
            """Create a ghost button."""
            kwargs['style'] = StyleType.GHOST
            return cls(*children, **kwargs)
        
        @classmethod
        def link(cls, *children, href: str, **kwargs) -> 'Btn'
        "Create a ghost button."
    
    def link(cls, *children, href: str, **kwargs) -> 'Btn':
            """Create a link-styled button."""
            kwargs['style'] = StyleType.LINK
            kwargs['href'] = href
            return cls(*children, **kwargs)
        
        @classmethod
        def outline(cls, *children, **kwargs) -> 'Btn'
        "Create a link-styled button."
    
    def outline(cls, *children, **kwargs) -> 'Btn':
            """Create an outline button."""
            kwargs['style'] = StyleType.OUTLINE
            return cls(*children, **kwargs)
        
        @classmethod
        def icon(cls, icon: FT, **kwargs) -> 'Btn'
        "Create an outline button."
    
    def icon(cls, icon: FT, **kwargs) -> 'Btn':
            """Create an icon-only button (typically square or circle)."""
            kwargs.setdefault('shape', ButtonShape.SQUARE)
            return cls(icon, **kwargs)
        
        @classmethod
        def submit(cls, text: str = "Submit", **kwargs) -> 'Btn'
        "Create an icon-only button (typically square or circle)."
    
    def submit(cls, text: str = "Submit", **kwargs) -> 'Btn':
            """Create a submit button."""
            return cls(text, type="submit", color=SemanticColor.PRIMARY, **kwargs)
        
        @classmethod
        def cancel(cls, text: str = "Cancel", **kwargs) -> 'Btn'
        "Create a submit button."
    
    def cancel(cls, text: str = "Cancel", **kwargs) -> 'Btn'
        "Create a cancel button."
```

### Colors (`colors.ipynb`)

> Semantic color system for daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.colors import (
    ColorClasses,
    ColorBuilder,
    get_color_classes,
    apply_semantic_colors,
    ColorMapping,
    with_opacity,
    ColorMixin
)
```

#### Functions

``` python
def get_color_classes(
    color: Union[SemanticColor, str],
    utilities: List[ColorUtility] = None  # List of utilities to generate (defaults to bg and text)
) -> List[str]:  # List of CSS class names
    "Generate color utility classes for a semantic color"
```

``` python
def apply_semantic_colors(
    bg: Optional[Union[SemanticColor, str]] = None,
    text: Optional[Union[SemanticColor, str]] = None,
    border: Optional[Union[SemanticColor, str]] = None,
    auto_content: bool = True  # Automatically select appropriate text color for background
) -> str:  # Space-separated CSS classes
    "Apply semantic colors with automatic content color selection"
```

``` python
def with_opacity(
    color_class: str,  # The color utility class (e.g., "bg-primary")
    opacity: Union[OpacityLevel, int]
) -> str:  # Color class with opacity modifier
    "Add opacity modifier to a color class"
```

#### Classes

``` python
@dataclass
class ColorClasses:
    "Container for color-related CSS classes"
    
    background: Optional[str]
    text: Optional[str]
    border: Optional[str]
    ring: Optional[str]
    
    def to_list(
            self
        ) -> List[str]:  # TODO: Add return description
        "Convert to list of class names"
    
    def to_string(
            self
        ) -> str:  # TODO: Add return description
        "Convert to space-separated string"
```

``` python
class ColorBuilder:
    def __init__(self):
        "TODO: Add function description"
        self._classes = ColorClasses()
    
    def bg(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
    """
    Builder for semantic color classes
    
    Provides a fluent API for building color-related CSS classes
    with daisyUI semantic colors.
    """
    
    def __init__(self):
            "TODO: Add function description"
            self._classes = ColorClasses()
        
        def bg(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "TODO: Add function description"
    
    def bg(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set background color"
    
    def text(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set text color"
    
    def border(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set border color"
    
    def ring(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set ring color"
    
    def brand_primary(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply primary brand colors (background + appropriate text)"
    
    def brand_secondary(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply secondary brand colors"
    
    def brand_accent(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply accent brand colors"
    
    def state_info(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply info state colors"
    
    def state_success(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply success state colors"
    
    def state_warning(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply warning state colors"
    
    def state_error(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply error state colors"
    
    def surface_base(
            self,
            level: SurfaceLevelType = 100  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply base surface colors"
    
    def build(
            self
        ) -> str:  # TODO: Add return description
        "Build the final class string"
    
    def build_list(
            self
        ) -> List[str]:  # TODO: Add return description
        "Build as a list of classes"
    
    def reset(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Reset the builder"
```

``` python
class ColorMapping:
    "Pre-defined color mappings for common use cases"
    
    def get_state_color(
            cls,  # TODO: Add type hint and description
            state: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a component state"
    
    def get_severity_color(
            cls,  # TODO: Add type hint and description
            severity: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a severity level"
    
    def get_status_color(
            cls,  # TODO: Add type hint and description
            status: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a status"
```

``` python
class ColorMixin(CSSContributor):
    """
    Mixin to add semantic color support to components
    
    This will be used by DaisyComponent to provide color methods.
    """
    
    def with_color(
            self,
            color: Union[SemanticColor, str],
            apply_to: List[ColorUtility] = None  # TODO: Add description
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply a semantic color to the component"
    
    def with_brand_colors(
            self,
            brand: Literal["primary", "secondary", "accent", "neutral"]
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply brand colors with appropriate text color"
    
    def with_state_colors(
            self,
            state: Literal["info", "success", "warning", "error"]
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply state colors with appropriate text color"
    
    def get_css_classes(self) -> CSSClasses
        "Get all color classes applied to this component

Returns:
    List of CSS class strings for colors"
```

### Configuration (`config.ipynb`)

> daisyUI configuration management for FastHTML projects

#### Import

``` python
from cjm_fasthtml_daisyui.core.config import (
    ThemeConfig,
    DaisyUIConfig,
    ColorScheme,
    ThemeDesignTokens,
    CustomTheme,
    ConfigManager
)
```

#### Classes

``` python
@dataclass
class ThemeConfig:
    "Configuration for a single theme"
    
    name: Union[DaisyUITheme, str]
    is_default: bool = False
    is_prefers_dark: bool = False
    
    def to_string(
            self
        ) -> str:  # TODO: Add return description
        "Convert to daisyUI config string format"
```

``` python
@dataclass
class DaisyUIConfig:
    """
    Complete daisyUI configuration for FastHTML projects
    
    Attributes:
        themes: List of themes to include (can be theme names or ThemeConfig objects)
        root: CSS selector for root element (default: ":root")
        include: Components to explicitly include (empty means all)
        exclude: Components to exclude
        prefix: Prefix for all daisyUI classes
        logs: Enable/disable console logs
    """
    
    themes: List[Union[DaisyUITheme, str, ThemeConfig]] = field(...)
    root: str = ':root'
    include: List[str] = field(...)
    exclude: List[Union[ExcludeFeature, str]] = field(...)
    prefix: str = ''
    logs: bool = True
    
    def add_theme(
            self, 
            theme: Union[DaisyUITheme, str],
            is_default: bool = False,  # TODO: Add description
            is_prefers_dark: bool = False  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Add a theme to the configuration"
    
    def exclude_feature(
            self,
            feature: Union[ExcludeFeature, str]  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Exclude a feature from daisyUI"
    
    def set_prefix(
            self,
            prefix: str  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Set a prefix for all daisyUI classes"
    
    def to_css(
            self
        ) -> str:  # TODO: Add return description
        "Generate CSS configuration string"
```

``` python
@dataclass
class ColorScheme:
    "Color scheme for a custom theme"
    
    base_100: str = 'oklch(98% 0.02 240)'
    base_200: str = 'oklch(95% 0.03 240)'
    base_300: str = 'oklch(92% 0.04 240)'
    base_content: str = 'oklch(20% 0.05 240)'
    primary: str = 'oklch(55% 0.3 240)'
    primary_content: str = 'oklch(98% 0.01 240)'
    secondary: str = 'oklch(70% 0.25 200)'
    secondary_content: str = 'oklch(98% 0.01 200)'
    accent: str = 'oklch(65% 0.25 160)'
    accent_content: str = 'oklch(98% 0.01 160)'
    neutral: str = 'oklch(50% 0.05 240)'
    neutral_content: str = 'oklch(98% 0.01 240)'
    info: str = 'oklch(70% 0.2 220)'
    info_content: str = 'oklch(98% 0.01 220)'
    success: str = 'oklch(65% 0.25 140)'
    success_content: str = 'oklch(98% 0.01 140)'
    warning: str = 'oklch(80% 0.25 80)'
    warning_content: str = 'oklch(20% 0.05 80)'
    error: str = 'oklch(65% 0.3 30)'
    error_content: str = 'oklch(98% 0.01 30)'
    
    def to_css_vars(
            self
        ) -> HTMLAttrs:  # TODO: Add return description
        "Convert to CSS variable format"
```

``` python
@dataclass
class ThemeDesignTokens:
    "Design tokens for theme customization"
    
    radius_selector: str = '1rem'  # For checkbox, toggle, badge
    radius_field: str = '0.25rem'  # For button, input, select, tab
    radius_box: str = '0.5rem'  # For card, modal, alert
    size_selector: str = '0.25rem'  # Base size for selectors
    size_field: str = '0.25rem'  # Base size for fields
    border: str = '1px'  # Border width
    depth: BinaryType = 1  # Shadow and 3D effect (0 or 1)
    noise: BinaryType = 0  # Noise texture effect (0 or 1)
    
    def to_css_vars(
            self
        ) -> HTMLAttrs:  # TODO: Add return description
        "Convert to CSS variable format"
```

``` python
@dataclass
class CustomTheme:
    "Complete custom theme definition"
    
    name: str
    is_default: bool = False
    is_prefers_dark: bool = False
    color_scheme: ColorSchemeType = 'light'
    colors: ColorScheme = field(...)
    tokens: ThemeDesignTokens = field(...)
    
    def to_css(
            self
        ) -> str:  # TODO: Add return description
        "Generate CSS for the custom theme"
```

``` python
class ConfigManager:
    "Manage daisyUI configuration persistence"
    
    def save_to_file(
            config: DaisyUIConfig,  # TODO: Add description
            path: Union[str, Path]  # TODO: Add description
        ): # TODO: Add type hint
        "Save configuration to a CSS file"
    
    def save_custom_theme(
            theme: CustomTheme,  # TODO: Add description
            path: Union[str, Path]  # TODO: Add description
        ): # TODO: Add type hint
        "Save custom theme to a CSS file"
    
    def combine_with_custom_themes(
            config: DaisyUIConfig,  # TODO: Add description
            custom_themes: List[CustomTheme]  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Combine configuration with custom themes"
```

### Elements (`elements.ipynb`)

> HTML element creation utilities

#### Import

``` python
from cjm_fasthtml_daisyui.core.elements import (
    create_element
)
```

#### Functions

``` python
def create_element(
    tag: str,  # HTML tag name (e.g., 'div', 'span', 'button')
    *children,  # Child elements
    **attrs  # HTML attributes
) -> FT:  # FastHTML element
    """
    Create a FastHTML element from a tag name.
    
    This function provides a centralized way to create HTML elements,
    avoiding duplication across modules.
    
    Args:
        tag: The HTML tag name (case-insensitive)
        *children: Child elements to include
        **attrs: HTML attributes for the element
        
    Returns:
        A FastHTML element of the specified type
        
    Examples:
        >>> create_element('div', 'Hello', cls='container')
        >>> create_element('button', 'Click me', type='submit')
    """
```

### HTMX Integration (`htmx.ipynb`)

> HTMX patterns and helpers for daisyUI components in FastHTML

#### Import

``` python
from cjm_fasthtml_daisyui.core.htmx import (
    HTMXAttrs,
    HTMXComponent,
    htmx_attrs,
    loading_indicator,
    oob_alert
)
```

#### Functions

``` python
def htmx_attrs(**kwargs) -> HTMLAttrs:
    """Convert keyword arguments to HTMX attributes.
    
    Converts Python-style names to HTMX attribute names:
    - get -> hx-get
    - trigger -> hx-trigger
    - etc.
    
    Returns:
        Dictionary with proper HTMX attribute names
    """
    attrs: HTMLAttrs = {}
    """
    Convert keyword arguments to HTMX attributes.
    
    Converts Python-style names to HTMX attribute names:
    - get -> hx-get
    - trigger -> hx-trigger
    - etc.
    
    Returns:
        Dictionary with proper HTMX attribute names
    """
```

``` python
def loading_indicator(
    indicator_id: str,  # ID for the indicator
    text: str = "Loading...",  # Loading text
    size: str = "md"  # Size of spinner (xs, sm, md, lg, xl)
) -> FT:  # Loading indicator element
    "Create a loading indicator element"
```

``` python
def oob_alert(
    message: str,  # Alert message
    alert_type: str = "info",  # Type (info, success, warning, error)
    target_id: str = "alerts",  # ID of container to append to
    auto_dismiss: Optional[int] = 5000  # Auto dismiss after milliseconds (None to disable)
) -> FT:  # Alert element with OOB swap
    "Create out-of-band alert message"
```

#### Classes

``` python
@dataclass
class HTMXAttrs:
    "Container for HTMX attributes with type-safe values."
    
    hx_get: Optional[str]
    hx_post: Optional[str]
    hx_put: Optional[str]
    hx_patch: Optional[str]
    hx_delete: Optional[str]
    hx_trigger: Optional[str]
    hx_target: Optional[str]
    hx_swap: Optional[str]
    hx_indicator: Optional[str]
    hx_push_url: Optional[Union[bool, str]]
    hx_select: Optional[str]
    hx_select_oob: Optional[str]
    hx_vals: Optional[HTMXValue]  # Using HTMXValue type alias
    hx_confirm: Optional[str]
    hx_disable: Optional[bool]
    hx_disabled_elt: Optional[str]
    hx_include: Optional[str]
    hx_ext: Optional[str]
    
    def to_dict(self) -> HTMLAttrs:
            """Convert to dictionary of HTML attributes.
            
            Returns:
                Dictionary with proper HTMX attribute names
            """
            attrs: HTMLAttrs = {}
        "Convert to dictionary of HTML attributes.

Returns:
    Dictionary with proper HTMX attribute names"
```

``` python
class HTMXComponent:
    def __init__(self, *args, htmx: Optional[HTMXAttrs] = None, **kwargs):
        """Initialize with optional HTMX attributes."""
        super().__init__(*args, **kwargs)
        self.htmx = htmx or HTMXAttrs()
    
    def with_htmx(
        self,
        get: Optional[str] = None,
        post: Optional[str] = None,
        put: Optional[str] = None,
        patch: Optional[str] = None,
        delete: Optional[str] = None,
        trigger: Optional[Union[HTMXTrigger, str]] = None,
        target: Optional[str] = None,
        swap: Optional[Union[HTMXSwap, str]] = None,
        **kwargs
    ) -> 'HTMXComponent'
    """
    Base class for HTMX-aware daisyUI components.
    
    Extends ValidatedDaisyComponent with HTMX attributes and helper methods
    for building interactive components following FastHTML patterns.
    """
    
    def __init__(self, *args, htmx: Optional[HTMXAttrs] = None, **kwargs):
            """Initialize with optional HTMX attributes."""
            super().__init__(*args, **kwargs)
            self.htmx = htmx or HTMXAttrs()
        
        def with_htmx(
            self,
            get: Optional[str] = None,
            post: Optional[str] = None,
            put: Optional[str] = None,
            patch: Optional[str] = None,
            delete: Optional[str] = None,
            trigger: Optional[Union[HTMXTrigger, str]] = None,
            target: Optional[str] = None,
            swap: Optional[Union[HTMXSwap, str]] = None,
            **kwargs
        ) -> 'HTMXComponent'
        "Initialize with optional HTMX attributes."
    
    def with_htmx(
            self,
            get: Optional[str] = None,
            post: Optional[str] = None,
            put: Optional[str] = None,
            patch: Optional[str] = None,
            delete: Optional[str] = None,
            trigger: Optional[Union[HTMXTrigger, str]] = None,
            target: Optional[str] = None,
            swap: Optional[Union[HTMXSwap, str]] = None,
            **kwargs
        ) -> 'HTMXComponent'
        "Configure HTMX attributes fluently.

Args:
    get/post/put/patch/delete: URL endpoints
    trigger: Event that triggers the request
    target: CSS selector for target element
    swap: How to swap the response
    **kwargs: Additional HTMX attributes
    
Returns:
    Self for method chaining"
    
    def with_loading(
            self,
            indicator_id: str,
            disable_during: Optional[str] = None
        ) -> 'HTMXComponent'
        "Configure loading indicators.

Args:
    indicator_id: ID of the loading indicator element
    disable_during: CSS selector of elements to disable during request
    
Returns:
    Self for method chaining"
    
    def with_confirmation(
            self,
            message: str
        ) -> 'HTMXComponent'
        "Add confirmation dialog.

Args:
    message: Confirmation message to show
    
Returns:
    Self for method chaining"
    
    def render_attrs(self) -> HTMLAttrs
        "Build all HTML attributes including HTMX.

Returns:
    Dictionary of all HTML attributes"
```

### Component Parts (`parts.ipynb`)

> System for handling component parts (e.g., card-body, modal-box)

#### Import

``` python
from cjm_fasthtml_daisyui.core.parts import (
    ComponentPart,
    HasParts
)
```

#### Classes

``` python
@dataclass
class ComponentPart:
    """
    Represents a part of a component (e.g., card-body, modal-box).
    
    Component parts are child elements that have specific styling
    within their parent component context.
    """
    
    name: str  # Part name (e.g., 'body', 'title', 'actions')
    parent_component: Union[str, DaisyComponentType]  # Parent component name or enum
    required: bool = False  # Whether this part is required
    tag: str = 'div'  # Default HTML tag for this part
    
    def class_name(self) -> CSSClass
        "Return the full class name for this part."
```

``` python
class HasParts:
    """
    Mixin for components that have child parts.
    
    This mixin provides functionality for components like cards, modals,
    and other complex components that have defined child elements.
    
    Note: Classes using this mixin should typically also implement the
    ComponentProtocol to ensure they provide the full component interface.
    Components that contribute CSS classes should also implement CSSContributor.
    """
    
    def parts(cls) -> Dict[str, ComponentPart]:
            """Return all available parts for this component.
            
            Subclasses should override this to define their parts.
            
            Returns:
                Dictionary mapping part names to ComponentPart instances
            """
            return {}
        
        def part(
            self,
            name: str,  # The part name (must be defined in parts())
            *children: FT,  # Child elements for this part
            **attrs: Any  # HTML attributes for the part
        ) -> FT
        "Return all available parts for this component.

Subclasses should override this to define their parts.

Returns:
    Dictionary mapping part names to ComponentPart instances"
    
    def part(
            self,
            name: str,  # The part name (must be defined in parts())
            *children: FT,  # Child elements for this part
            **attrs: Any  # HTML attributes for the part
        ) -> FT
        "Create a component part element.

Args:
    name: The part name (must be defined in parts())
    *children: Child elements for this part
    **attrs: HTML attributes for the part
    
Returns:
    FastHTML element with the appropriate part classes
    
Raises:
    ValueError: If the part name is not defined for this component"
```

### Placement & Direction (`placement.ipynb`)

> Mixins for component placement and direction options

#### Import

``` python
from cjm_fasthtml_daisyui.core.placement import (
    HasPlacement,
    HasDirection,
    HasPlacementAndDirection
)
```

#### Classes

``` python
@dataclass
class HasPlacement(CSSContributor):
    """
    Mixin for components with placement options.
    
    This mixin provides functionality for components that can be
    positioned in different locations (start, center, end, top, bottom, etc.).
    """
    
    placement: Optional[Union[DaisyPosition, PlacementType, str]]
    
    def get_css_classes(self) -> CSSClasses:
            """Get placement classes.
            
            Returns:
                List of CSS class strings for placement
            """
            if not self.placement
        "Get placement classes.

Returns:
    List of CSS class strings for placement"
    
    def uses_standard_placement(
            self
        ) -> bool:  # TODO: Add return description
        "Whether component uses standard '{component}-{placement}' pattern."
    
    def custom_placement_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Override for custom placement class patterns."
    
    def valid_placements(
            self
        ) -> List[Union[DaisyPosition, str]]:  # TODO: Add return description
        "Return list of valid placement values for this component."
```

``` python
@dataclass
class HasDirection(CSSContributor):
    """
    Mixin for components with direction options.
    
    This mixin provides functionality for components that can have
    different directional layouts (horizontal, vertical).
    """
    
    direction: Optional[DirectionType]
    
    def get_css_classes(self) -> CSSClasses:
            """Get direction classes.
            
            Returns:
                List of CSS class strings for direction
            """
            if not self.direction
        "Get direction classes.

Returns:
    List of CSS class strings for direction"
    
    def is_horizontal(
            self
        ) -> bool:  # TODO: Add return description
        "Check if component is horizontal."
    
    def is_vertical(
            self
        ) -> bool:  # TODO: Add return description
        "Check if component is vertical."
```

``` python
@dataclass
class HasPlacementAndDirection(HasPlacement, HasDirection):
    """
    Combined mixin for components with both placement and direction.
    
    This is useful for components like toast, divider, etc. that
    support both placement and direction options.
    """
    
    def get_css_classes(self) -> CSSClasses
        "Get combined placement and direction classes.

Returns:
    List of CSS class strings for placement and direction"
```

### Resources (`resources.ipynb`)

> Managing daisyUI and Tailwind CSS resources for FastHTML projects

#### Import

``` python
from cjm_fasthtml_daisyui.core.resources import (
    ResourceVersions,
    DaisyUIResources,
    ResourcePresets,
    ResourceOptimization,
    ResourceManager
)
```

#### Classes

``` python
@dataclass
class ResourceVersions:
    "Version management for daisyUI and Tailwind CSS"
    
    daisyui: str = '5'
    tailwind: str = '4'
    
    def get_daisyui_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for daisyUI"
    
    def get_daisyui_themes_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for daisyUI themes"
    
    def get_tailwind_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for Tailwind CSS browser version"
```

``` python
class DaisyUIResources:
    "Manages daisyUI and Tailwind CSS resources for FastHTML projects"
    
    def cdn_headers(
            versions: Optional[ResourceVersions] = None,  # TODO: Add description
            provider: CDNProvider = CDNProvider.JSDELIVR,  # TODO: Add description
            include_tailwind: bool = True,  # TODO: Add description
            additional_css: Optional[List[str]] = None,  # TODO: Add description
            additional_js: Optional[List[str]] = None  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "CDN-based resources for quick testing and development

Args:
    versions: Version configuration (defaults to latest stable)
    provider: CDN provider to use
    include_tailwind: Whether to include Tailwind CSS browser version
    additional_css: Extra CSS files to include
    additional_js: Extra JS files to include
    
Returns:
    List of FastHTML header elements"
    
    def local_headers(
            css_path: str = "/static/styles.css",  # TODO: Add description
            js_paths: Optional[List[str]] = None,  # TODO: Add description
            additional_css: Optional[List[str]] = None,  # TODO: Add description
            additional_js: Optional[List[str]] = None  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Local file-based resources for production use

Args:
    css_path: Path to compiled CSS file containing Tailwind + daisyUI
    js_paths: Paths to any JavaScript files
    additional_css: Extra CSS files to include
    additional_js: Extra JS files to include
    
Returns:
    List of FastHTML header elements"
    
    def inline_css(
            content: str,  # TODO: Add description
            id: Optional[str] = None  # TODO: Add description
        ) -> Style:  # TODO: Add return description
        "Create an inline CSS style element

Args:
    content: CSS content to inline
    id: Optional ID for the style element
    
Returns:
    FastHTML Style element"
    
    def minimal_css(
        ) -> str:  # TODO: Add return description
        "Get minimal CSS for Tailwind v4 with daisyUI plugin

Returns:
    CSS string with Tailwind and daisyUI imports"
```

``` python
class ResourcePresets:
    "Common resource configurations"
    
    def development(
        ) -> List[FT]:  # TODO: Add return description
        "Quick development setup with CDN resources"
    
    def production(
            css_path: str = "/static/styles.css"  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Production setup with compiled CSS"
    
    def testing(
        ) -> List[FT]:  # TODO: Add return description
        "Testing setup with fast CDN and no caching"
    
    def offline(
            css_path: str = "/static/daisyui.css",  # TODO: Add description
            tailwind_path: str = "/static/tailwind.js"  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Completely offline setup with local files"
```

``` python
@dataclass
class ResourceOptimization:
    "Advanced resource optimization options"
    
    preload: bool = True
    prefetch: bool = False
    async_load: bool = False
    defer: bool = False
    integrity: Optional[str]
    crossorigin: Optional[str] = 'anonymous'
    
    def apply_to_link(
            self,
            link_attrs: Dict[str, str]  # TODO: Add description
        ) -> Dict[str, str]:  # TODO: Add return description
        "Apply optimization attributes to a link element"
    
    def apply_to_script(
            self,
            script_attrs: Dict[str, str]  # TODO: Add description
        ) -> Dict[str, str]:  # TODO: Add return description
        "Apply optimization attributes to a script element"
```

``` python
class ResourceManager:
    def __init__(self):
        "TODO: Add function description"
        self._cache: Dict[str, List[FT]] = {}
    "Advanced resource manager with caching and optimization"
    
    def __init__(self):
            "TODO: Add function description"
            self._cache: Dict[str, List[FT]] = {}
        "TODO: Add function description"
    
    def get_optimized_headers(
            self,
            key: str = "default",  # TODO: Add description
            force_refresh: bool = False  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Get cached headers with optimization"
    
    def clear_cache(
            self
        ): # TODO: Add type hint
        "Clear the resource cache"
```

### Testing (`testing.ipynb`)

> Standardized testing framework for daisyUI components in Jupyter
> notebooks

#### Import

``` python
from cjm_fasthtml_daisyui.core.testing import (
    DisplayMode,
    ComponentExample,
    ComponentTester,
    quick_test,
    test_variants,
    theme_test,
    ComponentBuilder,
    TestData
)
```

#### Functions

``` python
def quick_test(
    *components: FT,
    title: str = "Quick Test"  # Title for the test page
) -> ComponentTester:  # Started ComponentTester instance
    "Quick function to test components"
```

``` python
def test_variants(
    component_fn: ComponentFactory,  # Function that creates the component
    variants: Dict[str, List[Any]],
    base_props: Optional[ComponentProps] = None,
    title: str = "Variant Testing"  # Title for the test page
) -> ComponentTester:  # Started ComponentTester instance
    "Test multiple variants of a component"
```

``` python
@contextmanager
def theme_test(
    themes: Optional[List[Union[DaisyUITheme, str]]] = None  # List of themes to test with (uses all themes if None)
)
    "Context manager for testing with specific themes"
```

#### Classes

``` python
class DisplayMode(str, Enum):
    "Component display modes for testing"
```

``` python
@dataclass
class ComponentExample:
    "Container for a component example with metadata"
    
    component: FT
    title: str
    description: Optional[str]
    code: Optional[str]
    props: Optional[ComponentProps]
    component_type: Optional[DaisyComponentType]
```

``` python
class ComponentTester:
    def __init__(
        self,
        title: str = "Component Showcase",  # Title for the showcase page
        pico: bool = False,  # Whether to include Pico CSS (should be False for daisyUI)
        config: Optional[DaisyUIConfig] = None,  # daisyUI configuration (only used with local resources)
        use_cdn: bool = True,  # Whether to use CDN resources (vs local)
        port: Optional[int] = 8000,  # Port for the test server
        available_themes: Optional[List[Union[DaisyUITheme, str]]] = None
    )
    """
    Standardized testing framework for daisyUI components in notebooks
    
    Provides an interactive environment for testing and showcasing components
    with theme switching, responsive preview, and documentation.
    """
    
    def __init__(
            self,
            title: str = "Component Showcase",  # Title for the showcase page
            pico: bool = False,  # Whether to include Pico CSS (should be False for daisyUI)
            config: Optional[DaisyUIConfig] = None,  # daisyUI configuration (only used with local resources)
            use_cdn: bool = True,  # Whether to use CDN resources (vs local)
            port: Optional[int] = 8000,  # Port for the test server
            available_themes: Optional[List[Union[DaisyUITheme, str]]] = None
        )
        "Initialize the component tester

Args:
    title: Title for the showcase page
    pico: Whether to include Pico CSS (should be False for daisyUI)
    config: daisyUI configuration (only used with local resources)
    use_cdn: Whether to use CDN resources (vs local)
    port: Port for the test server (defaults to 8000)
    available_themes: List of themes to show in selector (defaults to all when using CDN)"
    
    def add(
            self,
            component: Union[FT, ComponentFactory],
            title: str,
            description: Optional[str] = None,
            code: Optional[str] = None,
            component_type: Optional[DaisyComponentType] = None,
            **props: Any
        ) -> "ComponentTester"
        "Add a component example to the showcase

Args:
    component: Component or function that returns a component
    title: Title for this example
    description: Optional description
    code: Optional code snippet to display
    component_type: Optional component type for validation
    **props: Properties passed to the component if it's a function"
    
    def showcase(
            self,
            *components: FT,
            mode: DisplayMode = DisplayMode.SECTIONS,
            titles: Optional[List[str]] = None
        ) -> "ComponentTester"
        "Quick method to add multiple components

Args:
    *components: Components to showcase
    mode: How to display the components
    titles: Optional titles for each component"
    
    def start(self, open_browser: bool = False) -> "ComponentTester":
            """Start the test server"""
            if not self.server
        "Start the test server"
    
    def stop(self) -> None:
            """Stop the test server"""
            if self.server
        "Stop the test server"
```

``` python
class ComponentBuilder:
    def __init__(self, title: str = "Component Builder"):
        self.tester = ComponentTester(title=title)
        self.current_component = None
        self.component_history: List[FT] = []
    "Interactive component builder for notebooks"
    
    def __init__(self, title: str = "Component Builder"):
            self.tester = ComponentTester(title=title)
            self.current_component = None
            self.component_history: List[FT] = []
    
    def create(
            self,
            tag: str = "div",
            *children: Any,
            **attrs: Any
        ) -> "ComponentBuilder"
        "Create a new component"
    
    def add_class(self, *classes: CSSClass) -> "ComponentBuilder":
            """Add classes to the current component"""
            if self.current_component and hasattr(self.current_component, 'attrs')
        "Add classes to the current component"
    
    def add_child(self, child: FT) -> "ComponentBuilder":
            """Add a child to the current component"""
            if self.current_component
        "Add a child to the current component"
    
    def preview(self, title: Optional[str] = None) -> "ComponentBuilder":
            """Preview the current component"""
            if self.current_component
        "Preview the current component"
    
    def show(self) -> ComponentTester:
            """Show all previewed components"""
            return self.tester.start()
        
        def reset(self) -> "ComponentBuilder"
        "Show all previewed components"
    
    def reset(self) -> "ComponentBuilder"
        "Reset the builder"
```

``` python
class TestData:
    "Generate test data for components"
    
    def lorem(words: int = 10) -> str:
            """Generate lorem ipsum text"""
            lorem_words = [
                "lorem", "ipsum", "dolor", "sit", "amet", "consectetur",
                "adipiscing", "elit", "sed", "do", "eiusmod", "tempor",
                "incididunt", "ut", "labore", "et", "dolore", "magna",
                "aliqua", "enim", "ad", "minim", "veniam", "quis"
            ]
            result = []
            for i in range(words)
        "Generate lorem ipsum text"
    
    def image(width: int = 300, height: int = 200, category: str = "") -> str:
            """Generate placeholder image URL"""
            if category
        "Generate placeholder image URL"
    
    def avatar(size: int = 100, seed: Optional[str] = None) -> str:
            """Generate avatar URL"""
            if seed
        "Generate avatar URL"
    
    def items(count: int = 5, prefix: str = "Item") -> List[str]:
            """Generate list of items"""
            return [f"{prefix} {i+1}" for i in range(count)]
        
        @staticmethod
        def table_data(rows: int = 5, cols: int = 3) -> List[List[str]]
        "Generate list of items"
    
    def table_data(rows: int = 5, cols: int = 3) -> List[List[str]]:
            """Generate table data"""
            headers = [f"Column {i+1}" for i in range(cols)]
            data = []
            for r in range(rows)
        "Generate table data"
```

### Types (`types.ipynb`)

> Protocols, enums, type aliases, and utilities for type-safe daisyUI
> component development

#### Import

``` python
from cjm_fasthtml_daisyui.core.types import (
    CSSClasses,
    CSSClass,
    HTMLAttrs,
    Children,
    ComponentProps,
    ResponsiveDict,
    ColorValue,
    SizeValue,
    EventHandler,
    ComponentFactory,
    HTMXValue,
    DirectionType,
    PlacementType,
    HTTPMethod,
    ColorSchemeType,
    BrandType,
    StateType,
    CommonSizeType,
    SurfaceLevelType,
    BinaryType,
    CSSContributor,
    FeatureSupport,
    ComponentProtocol,
    DaisyComponentType,
    DaisyPosition,
    DaisyBreakpoint,
    DaisySize,
    Direction,
    SemanticColor,
    ColorUtility,
    OpacityLevel,
    StyleType,
    HTMXTrigger,
    HTMXSwap,
    DaisyUITheme,
    ExcludeFeature,
    CDNProvider,
    ensure_list,
    ensure_dict
)
```

#### Functions

``` python
def ensure_list(value: Union[str, List[str]]) -> List[str]:
    """Ensure a value is a list of strings.
    
    Args:
        value: String or list of strings
        
    Returns:
        List of strings
    """
    if isinstance(value, str)
    """
    Ensure a value is a list of strings.
    
    Args:
        value: String or list of strings
        
    Returns:
        List of strings
    """
```

``` python
def ensure_dict(value: Union[str, Dict[str, Any]]) -> Dict[str, Any]:
    """Ensure a value is a dictionary.
    
    Args:
        value: String (JSON) or dictionary
        
    Returns:
        Dictionary
    """
    if isinstance(value, str)
    """
    Ensure a value is a dictionary.
    
    Args:
        value: String (JSON) or dictionary
        
    Returns:
        Dictionary
    """
```

#### Classes

``` python
class CSSContributor(Protocol):
    """
    Protocol for mixins that contribute CSS classes.
    
    This standardizes the interface for all mixins that add CSS classes
    to components, replacing the various `*_classes()` methods.
    """
    
    def get_css_classes(self) -> CSSClasses
        "Return CSS classes from this contributor.

Returns:
    List of CSS class strings"
```

``` python
class FeatureSupport(Protocol):
    """
    Protocol for components with feature support.
    
    This standardizes the pattern of checking what features
    a component supports (color, size, glass, etc.).
    """
    
    def get_supported_features(self) -> Dict[str, bool]
        "Return dictionary of supported features.

Returns:
    Dictionary mapping feature names to support status
    
Example:
    {
        'color': True,
        'size': True,
        'glass': False,
        'active': True,
        'disabled': True,
        'loading': False
    }"
```

``` python
class ComponentProtocol(Protocol):
    """
    Base protocol for all daisyUI components.
    
    Defines the minimum interface that all components must implement.
    """
    
    def component_class(self) -> str:
            """Return the base component class name."""
            ...
        
        def build_classes(self) -> str
        "Return the base component class name."
    
    def build_classes(self) -> str:
            """Build complete class string."""
            ...
        
        def render_attrs(self) -> HTMLAttrs
        "Build complete class string."
    
    def render_attrs(self) -> HTMLAttrs
        "Build all HTML attributes for rendering."
```

``` python
class DaisyComponentType(str, Enum):
    """
    All available daisyUI component types with their CSS class names.
    
    This enum provides type-safe access to all daisyUI components,
    organized by category and mapping to their actual CSS class names.
    """
    
    def get_actions(cls) -> List['DaisyComponentType']:
            """Get all action components."""
            return [cls.BUTTON, cls.DROPDOWN, cls.MODAL, cls.SWAP, cls.THEME_CONTROLLER]
        
        @classmethod
        def get_data_display(cls) -> List['DaisyComponentType']
        "Get all action components."
    
    def get_data_display(cls) -> List['DaisyComponentType']:
            """Get all data display components."""
            return [
                cls.ACCORDION, cls.AVATAR, cls.BADGE, cls.CARD, cls.CAROUSEL,
                cls.CHAT, cls.COLLAPSE, cls.COUNTDOWN, cls.DIFF, cls.KBD,
                cls.LIST, cls.STAT, cls.STATUS, cls.TABLE, cls.TIMELINE
            ]
        
        @classmethod
        def get_data_input(cls) -> List['DaisyComponentType']
        "Get all data display components."
    
    def get_data_input(cls) -> List['DaisyComponentType']:
            """Get all data input components."""
            return [
                cls.CALENDAR, cls.CHECKBOX, cls.FIELDSET, cls.FILE_INPUT,
                cls.FILTER, cls.LABEL, cls.RADIO, cls.RANGE, cls.RATING,
                cls.SELECT, cls.TEXT_INPUT, cls.TEXTAREA, cls.TOGGLE, cls.VALIDATOR
            ]
        
        @classmethod
        def get_feedback(cls) -> List['DaisyComponentType']
        "Get all data input components."
    
    def get_feedback(cls) -> List['DaisyComponentType']:
            """Get all feedback components."""
            return [
                cls.ALERT, cls.LOADING, cls.PROGRESS, cls.RADIAL_PROGRESS,
                cls.SKELETON, cls.TOAST, cls.TOOLTIP
            ]
        
        @classmethod
        def get_layout(cls) -> List['DaisyComponentType']
        "Get all feedback components."
    
    def get_layout(cls) -> List['DaisyComponentType']:
            """Get all layout components."""
            return [
                cls.DIVIDER, cls.DRAWER, cls.FOOTER, cls.HERO,
                cls.INDICATOR, cls.JOIN, cls.MASK, cls.STACK
            ]
        
        @classmethod
        def get_mockup(cls) -> List['DaisyComponentType']
        "Get all layout components."
    
    def get_mockup(cls) -> List['DaisyComponentType']:
            """Get all mockup components."""
            return [
                cls.MOCKUP_BROWSER, cls.MOCKUP_CODE,
                cls.MOCKUP_PHONE, cls.MOCKUP_WINDOW
            ]
        
        @classmethod
        def get_navigation(cls) -> List['DaisyComponentType']
        "Get all mockup components."
    
    def get_navigation(cls) -> List['DaisyComponentType']:
            """Get all navigation components."""
            return [
                cls.BREADCRUMBS, cls.DOCK, cls.LINK, cls.MENU,
                cls.NAVBAR, cls.PAGINATION, cls.STEPS, cls.TAB
            ]
        
        def get_component_class(self) -> str
        "Get all navigation components."
    
    def get_component_class(self) -> str:
            """Get the base CSS class name for this component type."""
            return self.value
        
        def get_category(self) -> str
        "Get the base CSS class name for this component type."
    
    def get_category(self) -> str:
            """Get the category this component belongs to."""
            if self in self.get_actions()
        "Get the category this component belongs to."
```

``` python
class DaisyPosition(str, Enum):
    "Common position values."
```

``` python
class DaisyBreakpoint(str, Enum):
    "Responsive breakpoints."
```

``` python
class DaisySize(str, Enum):
    "Common size variants across components."
```

``` python
class Direction(str, Enum):
    "Component direction options."
```

``` python
class SemanticColor(str, Enum):
    """
    daisyUI semantic colors that adapt to themes
    
    These colors change based on the active theme, providing
    consistent semantic meaning across different visual styles.
    """
    
    def with_content(
            self
        ) -> "SemanticColor":  # TODO: Add return description
        "Get the corresponding content color for this semantic color"
    
    def is_brand_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a brand color"
    
    def is_state_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a state/semantic color"
    
    def is_base_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a base/surface color"
    
    def is_content_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a content/text color"
```

``` python
class ColorUtility(str, Enum):
    "CSS utility prefixes that work with semantic colors"
    
    def with_color(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Generate a utility class with a color"
```

``` python
class OpacityLevel(int, Enum):
    "Standard opacity levels"
```

``` python
class StyleType(str, Enum):
    """
    Common style modifiers across components.
    
    These were previously in modifiers.ipynb but are now part of the
    unified variant system.
    """
```

``` python
class HTMXTrigger(str, Enum):
    "Common HTMX trigger events"
    
    def with_modifier(
            self,
            modifier: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add modifier to trigger (e.g., 'click once')"
    
    def delayed(
            self,
            delay: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add delay to trigger (e.g., 'keyup delay:500ms')"
    
    def changed(
            self
        ) -> str:  # TODO: Add return description
        "Add changed modifier (e.g., 'keyup changed')"
```

``` python
class HTMXSwap(str, Enum):
    "HTMX swap strategies"
    
    def with_modifier(
            self,
            modifier: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add swap modifier (e.g., 'innerHTML swap:500ms')"
    
    def with_transition(
            self,
            duration: str = "500ms"  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add swap transition"
```

``` python
class DaisyUITheme(str, Enum):
    "Built-in daisyUI themes"
```

``` python
class ExcludeFeature(str, Enum):
    "Features that can be excluded from daisyUI"
```

``` python
class CDNProvider(str, Enum):
    "Supported CDN providers for daisyUI and Tailwind CSS"
    
    def get_base_url(
            self
        ) -> str:  # TODO: Add return description
        "Get the base URL for the CDN provider"
```

#### Variables

``` python
ColorValue  # Forward reference
SizeValue  # Forward reference
DirectionType  # # Direction literals
PlacementType  # Placement literals
HTTPMethod  # HTTP method literals
ColorSchemeType  # Theme color scheme
BrandType  # Brand types
StateType  # State types
CommonSizeType  # Size types (commonly used)
SurfaceLevelType  # Surface level literals (for base colors)
BinaryType  # Binary value literals (for theme design tokens)
```

### Variant System (`variants.ipynb`)

> System for handling component variants and states

#### Import

``` python
from cjm_fasthtml_daisyui.core.variants import (
    HasGlass,
    Variant,
    HasVariants,
    CompoundVariant,
    HasCompoundVariants,
    create_style_variant
)
```

#### Functions

``` python
def create_style_variant(component_prefix: str) -> Variant
    """
    Create a style variant with component-specific class names.
    
    Args:
        component_prefix: The component prefix (e.g., 'btn', 'badge')
        
    Returns:
        Variant with component-specific style classes
    """
```

#### Classes

``` python
@dataclass
class HasGlass(CSSContributor):
    """
    Mixin for components that support glass morphism effect.
    
    This mixin provides the glass effect styling for daisyUI components.
    The glass effect creates a frosted glass appearance.
    """
    
    glass: bool = False
    
    def get_css_classes(self) -> CSSClasses:
            """Get glass effect CSS classes.
            
            Returns:
                List of CSS class strings for glass effect
            """
            if self.glass
        "Get glass effect CSS classes.

Returns:
    List of CSS class strings for glass effect"
```

``` python
@dataclass
class Variant:
    """
    Represents a component variant.
    
    Variants allow components to have different appearances based on props.
    Inspired by CVA (Class Variance Authority) pattern.
    """
    
    name: str  # Variant name (e.g., 'intent', 'size')
    options: Dict[str, Union[str, List[str]]]  # Option -> classes mapping
    default: Optional[str]  # Default option
    
    def get_classes(
            self,
            value: Optional[str]  # TODO: Add description
        ) -> List[str]:  # TODO: Add return description
        "Get classes for a variant value."
```

``` python
class HasVariants(CSSContributor):
    """
    Mixin for components with variant support.
    
    This provides a more flexible alternative to individual boolean flags
    for component variations.
    """
    
    def variants(
            cls  # TODO: Add type hint and description
        ) -> Dict[str, Variant]:  # TODO: Add return description
        "Define available variants.

Subclasses should override this to define their variants."
    
    def get_css_classes(self) -> CSSClasses:
            """Get all classes from variants.
            
            Returns:
                List of CSS class strings from variants
            """
            classes = []
            variants = self.variants()
            
            for variant_name, variant in variants.items()
        "Get all classes from variants.

Returns:
    List of CSS class strings from variants"
    
    def set_variant(
            self,
            name: str,  # TODO: Add description
            value: str  # TODO: Add description
        ) -> 'HasVariants':  # TODO: Add return description
        "Set a variant value and return self for chaining."
```

``` python
@dataclass
class CompoundVariant:
    "Represents a compound variant that depends on multiple conditions."
    
    conditions: Dict[str, str]  # variant_name -> required_value
    classes: Union[str, List[str]]  # Classes to apply when conditions met
    
    def matches(
            self,
            variant_values: Dict[str, Optional[str]]  # TODO: Add description
        ) -> bool:  # TODO: Add return description
        "Check if all conditions are met."
    
    def get_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Get classes for this compound variant."
```

``` python
class HasCompoundVariants(HasVariants):
    "Extended mixin that supports compound variants."
    
    def compound_variants(
            cls  # TODO: Add type hint and description
        ) -> List[CompoundVariant]:  # TODO: Add return description
        "Define compound variants.

Subclasses should override this to define compound variants."
    
    def get_css_classes(self) -> CSSClasses:
            """Get all classes from variants including compound variants.
            
            Returns:
                List of CSS class strings from variants and compound variants
            """
            classes = super().get_css_classes()
            
            # Check compound variants
            for compound in self.compound_variants()
        "Get all classes from variants including compound variants.

Returns:
    List of CSS class strings from variants and compound variants"
```
