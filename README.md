# cjm-fasthtml-daisyui


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

> Python-native UI components for FastHTML using daisyUI v5 and Tailwind
> CSS v4

A fully Python-abstracted UI component library that provides reusable
components built with [Tailwind CSS
v4](https://tailwindcss.com/blog/tailwindcss-v4) (abstracted through the
[`cjm-tailwind-utils`](https://cj-mills.github.io/cjm-tailwind-utils/)
library) and [daisyUI v5](https://daisyui.com/docs/v5/) for
[FastHTML](https://www.fastht.ml/docs/) projects.

## Install

``` bash
pip install cjm-fasthtml-daisyui
```

## Project Structure

    nbs/
    ├── actions/ (1)
    │   └── button.ipynb             # Buttons allow the user to take actions or make choices.
    └── core/ (15)
        ├── animation.ipynb          # Support for component animations and transitions
        ├── base.ipynb               # Base classes and types for all daisyUI components
        ├── behaviors.ipynb          # Mixin for components with behavior states (active, disabled, loading)
        ├── colors.ipynb             # Semantic color system for daisyUI components
        ├── config.ipynb             # daisyUI configuration management for FastHTML projects
        ├── factory.ipynb            # Factory functions for creating daisyUI components
        ├── htmx.ipynb               # HTMX patterns and helpers for daisyUI components in FastHTML
        ├── parts.ipynb              # System for handling component parts (e.g., card-body, modal-box)
        ├── placement.ipynb          # Mixins for component placement and direction options
        ├── resources.ipynb          # Managing daisyUI and Tailwind CSS resources for FastHTML projects
        ├── testing.ipynb            # Standardized testing framework for daisyUI components in Jupyter notebooks
        ├── types.ipynb              # Common types and type aliases for daisyUI components
        ├── utils.ipynb              # Shared utility functions for daisyUI components
        ├── validation.ipynb         # Enforcing daisyUI 5 usage rules and best practices
        └── variants.ipynb           # System for handling component variants and states

Total: 17 notebooks across 2 directories

## Module Dependencies

``` mermaid
graph LR
    actions_button[actions.button<br/>Button]
    core_animation[core.animation<br/>Animation & Transitions]
    core_base[core.base<br/>Core Base Classes]
    core_behaviors[core.behaviors<br/>Behavior States]
    core_colors[core.colors<br/>Colors]
    core_config[core.config<br/>Configuration]
    core_factory[core.factory<br/>Component Factory]
    core_htmx[core.htmx<br/>HTMX Integration]
    core_parts[core.parts<br/>Component Parts]
    core_placement[core.placement<br/>Placement & Direction]
    core_resources[core.resources<br/>Resources]
    core_testing[core.testing<br/>Testing]
    core_types[core.types<br/>Types]
    core_utils[core.utils<br/>Utilities]
    core_validation[core.validation<br/>Validation]
    core_variants[core.variants<br/>Variant System]

    actions_button --> core_htmx
    actions_button --> core_variants
    actions_button --> core_colors
    actions_button --> core_config
    actions_button --> core_base
    actions_button --> core_behaviors
    actions_button --> core_testing
    core_animation --> core_types
    core_base --> core_colors
    core_behaviors --> core_types
    core_colors --> core_types
    core_factory --> core_base
    core_factory --> core_utils
    core_htmx --> core_base
    core_htmx --> core_colors
    core_parts --> core_utils
    core_placement --> core_types
    core_testing --> core_colors
    core_testing --> core_config
    core_testing --> core_resources
    core_validation --> core_base
    core_validation --> core_colors
    core_variants --> core_types

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px
```

*23 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Animation & Transitions (`animation.ipynb`)

> Support for component animations and transitions

#### Import

``` python
from cjm_fasthtml_daisyui.core.animation import (
    AnimationType,
    TransitionProperty,
    HasAnimation,
    LoadingAnimation,
    SwapAnimation
)
```

#### Classes

``` python
class AnimationType(str, Enum):
    "Common animation types."
```

``` python
class TransitionProperty(str, Enum):
    "Transition properties."
```

``` python
class HasAnimation(CSSContributor):
    """
    Mixin for components with animation support.
    
    This provides animation and transition utilities for components.
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get animation-related classes.
            
            Returns:
                List of CSS class strings for animations
            """
            tb = TailwindBuilder()
            
            # Add animation
            if self.animate
        "Get animation-related classes.

Returns:
    List of CSS class strings for animations"
    
    def with_animation(self,
                          animate: Optional[AnimationType] = None,  # TODO: Add description
                          transition: Optional[TransitionProperty] = None,  # TODO: Add description
                          duration: Optional[int] = None,  # TODO: Add description
                          delay: Optional[int] = None) -> 'HasAnimation'
        "Configure animation and return self for chaining."
```

``` python
class LoadingAnimation:
    "Animation patterns for loading states."
    
    def spinner(
        ) -> List[str]:  # TODO: Add return description
        "Spinning loader animation."
    
    def dots(
        ) -> List[str]:  # TODO: Add return description
        "Pulsing dots animation."
    
    def skeleton(
        ) -> List[str]:  # TODO: Add return description
        "Skeleton loading animation."
```

``` python
class SwapAnimation:
    "Animation patterns for swap components."
    
    def rotate(
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Rotation swap animation."
    
    def flip(
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Flip swap animation."
```

### Core Base Classes (`base.ipynb`)

> Base classes and types for all daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.base import (
    DaisyPosition,
    DaisyBreakpoint,
    DaisySize,
    DaisyComponent
)
```

#### Classes

``` python
class DaisyPosition(str, Enum):
    "Common position values."
```

``` python
class DaisyBreakpoint(str, Enum):
    "Responsive breakpoints."
```

``` python
class DaisySize(str, Enum):
    "Common size variants across components."
```

``` python
@dataclass
class DaisyComponent(ColorMixin):
    """
    Base class for all daisyUI components.
    
    This class provides the foundation for building daisyUI components with:
    - Type-safe semantic color support with automatic content colors
    - Custom class and attribute support
    - Integration with cjm-tailwind-utils for additional styling
    - Responsive modifier support
    """
    
    id: Optional[str]
    cls: Optional[str]  # Additional custom classes
    attrs: Dict[str, Any] = field(...)
    color: Optional[Union[SemanticColor, str]]
    size: Optional[Union[DaisySize, str]]
    glass: bool = False  # Glass effect modifier
    responsive_size: Optional[Dict[str, str]]
    responsive_hide: Optional[List[str]]  # Breakpoints to hide at
    responsive_show: Optional[List[str]]  # Breakpoints to show at
    tw_padding: Optional[Union[int, str]]
    tw_margin: Optional[Union[int, str]]
    tw_utilities: Optional[List[str]]  # Raw Tailwind utilities
    
    def component_class(
            self
        ) -> str:  # TODO: Add return description
        "Return the base component class name (e.g., 'btn', 'card')."
    
    def modifier_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Return all modifier classes for this component."
    
    def supports_color(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports color modifiers."
    
    def supports_size(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports size modifiers."
    
    def supports_glass(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports glass effect."
    
    def build_classes(
            self
        ) -> str:  # TODO: Add return description
        "Build complete class string with deduplication."
    
    def render_attrs(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Build all HTML attributes for rendering."
    
    def with_utilities(
            self,
            *utilities: str
        ) -> 'DaisyComponent':  # TODO: Add return description
        "Add Tailwind utilities and return self for chaining."
    
    def with_semantic_colors(
            self,
            bg: Optional[Union[SemanticColor, str]] = None,
            text: Optional[Union[SemanticColor, str]] = None,
            border: Optional[Union[SemanticColor, str]] = None,
            auto_content: bool = True  # TODO: Add description
        ) -> 'DaisyComponent':  # TODO: Add return description
        "Apply semantic colors with automatic content color selection.

Args:
    bg: Background color
    text: Text color (auto-selected if None and auto_content=True)
    border: Border color  
    auto_content: Automatically select appropriate text color for background
    
Returns:
    Self for method chaining"
```

### Behavior States (`behaviors.ipynb`)

> Mixin for components with behavior states (active, disabled, loading)

#### Import

``` python
from cjm_fasthtml_daisyui.core.behaviors import (
    HasBehaviors,
    InteractiveMixin,
    FormControlMixin
)
```

#### Classes

``` python
class HasBehaviors(CSSContributor):
    """
    Mixin for components with behavior states.
    
    This mixin provides functionality for interactive components
    that can be active, disabled, loading, etc.
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get behavior state classes.
            
            Returns:
                List of CSS class strings for behavior states
            """
            classes = []
            base = self.component_class()
            
            if self.active and self.supports_active()
        "Get behavior state classes.

Returns:
    List of CSS class strings for behavior states"
    
    def supports_active(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports active state."
    
    def supports_disabled(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports disabled state."
    
    def supports_loading(
            self
        ) -> bool:  # TODO: Add return description
        "Whether this component supports loading state."
    
    def loading_uses_base_class(
            self
        ) -> bool:  # TODO: Add return description
        "Whether loading state uses 'loading' instead of '{component}-loading'."
    
    def behavior_attrs(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Return HTML attributes for behavior states."
```

``` python
class InteractiveMixin(HasBehaviors):
    """
    Extended mixin for interactive components.
    
    This combines HasBehaviors with additional interactive properties
    commonly needed for buttons, inputs, and other interactive elements.
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get all interactive state classes.
            
            Returns:
                List of CSS class strings for interactive states
            """
            classes = super().get_css_classes()
            base = self.component_class()
            
            if self.focus and hasattr(self, 'supports_focus') and self.supports_focus()
        "Get all interactive state classes.

Returns:
    List of CSS class strings for interactive states"
```

``` python
class FormControlMixin:
    """
    Mixin for form control components.
    
    This mixin provides common properties and methods for
    form elements like inputs, selects, textareas, etc.
    """
    
    def form_attrs(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Return form-related HTML attributes."
```

### Button (`button.ipynb`)

> [Buttons](https://daisyui.com/components/button/) allow the user to
> take actions or make choices.

#### Import

``` python
from cjm_fasthtml_daisyui.actions.button import (
    ButtonShape,
    Btn,
    ButtonGroup
)
```

#### Classes

``` python
class ButtonShape(str, Enum):
    "Button shape modifiers"
```

``` python
@dataclass
class Btn:
    def __init__(self, *children, **kwargs)
    """
    daisyUI Button component with full feature support.
    
    Supports all button variants, styles, sizes, shapes, and states.
    Can be used as a regular button, submit button, or link button.
    
    Examples:
        Basic button:
            Btn("Click me", color=SemanticColor.PRIMARY)
        
        Icon button:
            Btn(Icon("heart"), shape=ButtonShape.CIRCLE, style=StyleType.GHOST)
        
        Loading button:
            Btn("Submit", loading=True, disabled=True)
    """
    
    children: List[Any] = field(...)
    shape: Optional[ButtonShape]
    no_animation: bool = False  # Disable click animation
    icon_start: Optional[FT]
    icon_end: Optional[FT]
    href: Optional[str]
    target: Optional[str]
    type: Optional[str]
    form: Optional[str]
    style: Optional[Union[StyleType, str]]
    
    def __init__(self, *children, **kwargs)
        "TODO: Add function description"
    
    def variants(cls) -> Dict[str, Any]:
            """Define available variants for buttons.
            
            Returns:
                Dictionary of variant definitions
            """
            return {
                "style": create_style_variant("btn")
        "Define available variants for buttons.

Returns:
    Dictionary of variant definitions"
    
    def component_class(
            self
        ) -> str:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_color(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_size(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_glass(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_active(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_disabled(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def supports_loading(
            self
        ) -> bool:  # TODO: Add return description
        "TODO: Add function description"
    
    def modifier_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Build all modifier classes"
    
    def render_content(
            self
        ) -> List[FT]:  # TODO: Add return description
        "Render button content with icons"
    
    def render_attrs(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Build all HTML attributes including form and behavior attrs."
    
    def render(
            self
        ) -> FT:  # TODO: Add return description
        "Render the button element"
    
    def primary(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a primary button"
    
    def secondary(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a secondary button"
    
    def accent(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create an accent button"
    
    def success(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a success button"
    
    def error(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create an error/danger button"
    
    def warning(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a warning button"
    
    def info(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create an info button"
    
    def ghost(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a ghost button"
    
    def link(
            cls,  # TODO: Add type hint and description
            *children,
            href: str,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a link-styled button"
    
    def outline(
            cls,  # TODO: Add type hint and description
            *children,
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create an outline button"
    
    def icon(
            cls,  # TODO: Add type hint and description
            icon: FT,  # TODO: Add description
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create an icon-only button (typically square or circle)"
    
    def submit(
            cls,  # TODO: Add type hint and description
            text: str = "Submit",  # TODO: Add description
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a submit button"
    
    def cancel(
            cls,  # TODO: Add type hint and description
            text: str = "Cancel",  # TODO: Add description
            **kwargs
        ) -> 'Btn':  # TODO: Add return description
        "Create a cancel button"
```

``` python
@dataclass
class ButtonGroup:
    "Helper class for creating button groups"
    
    def actions(
            *buttons: Btn,
            justify: str = "end"
        ) -> FT:  # TODO: Add return description
        "Create an actions button group (commonly used in cards/modals)"
    
    def toolbar(
            *buttons: Btn,
            vertical: bool = False
        ) -> FT:  # TODO: Add return description
        "Create a toolbar-style button group"
    
    def pagination(
            current: int,  # TODO: Add description
            total: int,  # TODO: Add description
            on_page: Optional[str] = None,  # TODO: Add description
            size: DaisySize = DaisySize.MD  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create a pagination button group"
```

### Colors (`colors.ipynb`)

> Semantic color system for daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.colors import (
    SemanticColor,
    ColorUtility,
    ColorClasses,
    ColorBuilder,
    get_color_classes,
    apply_semantic_colors,
    ColorMapping,
    OpacityLevel,
    with_opacity,
    ColorMixin
)
```

#### Functions

``` python
def get_color_classes(
    color: Union[SemanticColor, str],
    utilities: List[ColorUtility] = None  # List of utilities to generate (defaults to bg and text)
) -> List[str]:  # List of CSS class names
    "Generate color utility classes for a semantic color"
```

``` python
def apply_semantic_colors(
    bg: Optional[Union[SemanticColor, str]] = None,
    text: Optional[Union[SemanticColor, str]] = None,
    border: Optional[Union[SemanticColor, str]] = None,
    auto_content: bool = True  # Automatically select appropriate text color for background
) -> str:  # Space-separated CSS classes
    "Apply semantic colors with automatic content color selection"
```

``` python
def with_opacity(
    color_class: str,  # The color utility class (e.g., "bg-primary")
    opacity: Union[OpacityLevel, int]
) -> str:  # Color class with opacity modifier
    "Add opacity modifier to a color class"
```

#### Classes

``` python
class SemanticColor(str, Enum):
    """
    daisyUI semantic colors that adapt to themes
    
    These colors change based on the active theme, providing
    consistent semantic meaning across different visual styles.
    """
    
    def with_content(
            self
        ) -> "SemanticColor":  # TODO: Add return description
        "Get the corresponding content color for this semantic color"
    
    def is_brand_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a brand color"
    
    def is_state_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a state/semantic color"
    
    def is_base_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a base/surface color"
    
    def is_content_color(
            self
        ) -> bool:  # TODO: Add return description
        "Check if this is a content/text color"
```

``` python
class ColorUtility(str, Enum):
    "CSS utility prefixes that work with semantic colors"
    
    def with_color(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Generate a utility class with a color"
```

``` python
@dataclass
class ColorClasses:
    "Container for color-related CSS classes"
    
    background: Optional[str]
    text: Optional[str]
    border: Optional[str]
    ring: Optional[str]
    
    def to_list(
            self
        ) -> List[str]:  # TODO: Add return description
        "Convert to list of class names"
    
    def to_string(
            self
        ) -> str:  # TODO: Add return description
        "Convert to space-separated string"
```

``` python
class ColorBuilder:
    def __init__(self):
        "TODO: Add function description"
        self._classes = ColorClasses()
    
    def bg(
        self,
        color: Union[SemanticColor, str]  # TODO: Add description
    ) -> "ColorBuilder":  # TODO: Add return description
    """
    Builder for semantic color classes
    
    Provides a fluent API for building color-related CSS classes
    with daisyUI semantic colors.
    """
    
    def __init__(self):
            "TODO: Add function description"
            self._classes = ColorClasses()
        
        def bg(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "TODO: Add function description"
    
    def bg(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set background color"
    
    def text(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set text color"
    
    def border(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set border color"
    
    def ring(
            self,
            color: Union[SemanticColor, str]  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Set ring color"
    
    def brand_primary(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply primary brand colors (background + appropriate text)"
    
    def brand_secondary(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply secondary brand colors"
    
    def brand_accent(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply accent brand colors"
    
    def state_info(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply info state colors"
    
    def state_success(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply success state colors"
    
    def state_warning(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply warning state colors"
    
    def state_error(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply error state colors"
    
    def surface_base(
            self,
            level: Literal[100, 200, 300] = 100  # TODO: Add description
        ) -> "ColorBuilder":  # TODO: Add return description
        "Apply base surface colors"
    
    def build(
            self
        ) -> str:  # TODO: Add return description
        "Build the final class string"
    
    def build_list(
            self
        ) -> List[str]:  # TODO: Add return description
        "Build as a list of classes"
    
    def reset(
            self
        ) -> "ColorBuilder":  # TODO: Add return description
        "Reset the builder"
```

``` python
class ColorMapping:
    "Pre-defined color mappings for common use cases"
    
    def get_state_color(
            cls,  # TODO: Add type hint and description
            state: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a component state"
    
    def get_severity_color(
            cls,  # TODO: Add type hint and description
            severity: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a severity level"
    
    def get_status_color(
            cls,  # TODO: Add type hint and description
            status: str  # TODO: Add description
        ) -> Optional[SemanticColor]:  # TODO: Add return description
        "Get semantic color for a status"
```

``` python
class OpacityLevel(int, Enum):
    "Standard opacity levels"
```

``` python
class ColorMixin(CSSContributor):
    """
    Mixin to add semantic color support to components
    
    This will be used by DaisyComponent to provide color methods.
    """
    
    def with_color(
            self,
            color: Union[SemanticColor, str],
            apply_to: List[ColorUtility] = None  # TODO: Add description
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply a semantic color to the component"
    
    def with_brand_colors(
            self,
            brand: Literal["primary", "secondary", "accent", "neutral"]
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply brand colors with appropriate text color"
    
    def with_state_colors(
            self,
            state: Literal["info", "success", "warning", "error"]
        ) -> "ColorMixin":  # TODO: Add return description
        "Apply state colors with appropriate text color"
    
    def get_css_classes(self) -> CSSClasses
        "Get all color classes applied to this component

Returns:
    List of CSS class strings for colors"
```

### Configuration (`config.ipynb`)

> daisyUI configuration management for FastHTML projects

#### Import

``` python
from cjm_fasthtml_daisyui.core.config import (
    DaisyUITheme,
    ThemeConfig,
    ExcludeFeature,
    DaisyUIConfig,
    ConfigPresets,
    ColorScheme,
    ThemeDesignTokens,
    CustomTheme,
    ConfigManager
)
```

#### Classes

``` python
class DaisyUITheme(str, Enum):
    "Built-in daisyUI themes"
```

``` python
@dataclass
class ThemeConfig:
    "Configuration for a single theme"
    
    name: Union[DaisyUITheme, str]
    is_default: bool = False
    is_prefers_dark: bool = False
    
    def to_string(
            self
        ) -> str:  # TODO: Add return description
        "Convert to daisyUI config string format"
```

``` python
class ExcludeFeature(str, Enum):
    "Features that can be excluded from daisyUI"
```

``` python
@dataclass
class DaisyUIConfig:
    """
    Complete daisyUI configuration for FastHTML projects
    
    Attributes:
        themes: List of themes to include (can be theme names or ThemeConfig objects)
        root: CSS selector for root element (default: ":root")
        include: Components to explicitly include (empty means all)
        exclude: Components to exclude
        prefix: Prefix for all daisyUI classes
        logs: Enable/disable console logs
    """
    
    themes: List[Union[DaisyUITheme, str, ThemeConfig]] = field(...)
    root: str = ':root'
    include: List[str] = field(...)
    exclude: List[Union[ExcludeFeature, str]] = field(...)
    prefix: str = ''
    logs: bool = True
    
    def add_theme(
            self, 
            theme: Union[DaisyUITheme, str],
            is_default: bool = False,  # TODO: Add description
            is_prefers_dark: bool = False  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Add a theme to the configuration"
    
    def exclude_feature(
            self,
            feature: Union[ExcludeFeature, str]  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Exclude a feature from daisyUI"
    
    def set_prefix(
            self,
            prefix: str  # TODO: Add description
        ) -> "DaisyUIConfig":  # TODO: Add return description
        "Set a prefix for all daisyUI classes"
    
    def to_css(
            self
        ) -> str:  # TODO: Add return description
        "Generate CSS configuration string"
```

``` python
class ConfigPresets:
    "Pre-configured daisyUI configurations for common use cases"
    
    def minimal(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Minimal configuration with just light theme"
    
    def default(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Default configuration with light and dark themes"
    
    def all_themes(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Configuration with all available themes"
    
    def corporate(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Professional configuration with corporate themes"
    
    def creative(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Creative configuration with colorful themes"
    
    def accessible(
        ) -> DaisyUIConfig:  # TODO: Add return description
        "High contrast configuration for accessibility"
    
    def prefixed(
            prefix: str = "daisy-"  # TODO: Add description
        ) -> DaisyUIConfig:  # TODO: Add return description
        "Configuration with prefixed classes to avoid conflicts"
```

``` python
@dataclass
class ColorScheme:
    "Color scheme for a custom theme"
    
    base_100: str = 'oklch(98% 0.02 240)'
    base_200: str = 'oklch(95% 0.03 240)'
    base_300: str = 'oklch(92% 0.04 240)'
    base_content: str = 'oklch(20% 0.05 240)'
    primary: str = 'oklch(55% 0.3 240)'
    primary_content: str = 'oklch(98% 0.01 240)'
    secondary: str = 'oklch(70% 0.25 200)'
    secondary_content: str = 'oklch(98% 0.01 200)'
    accent: str = 'oklch(65% 0.25 160)'
    accent_content: str = 'oklch(98% 0.01 160)'
    neutral: str = 'oklch(50% 0.05 240)'
    neutral_content: str = 'oklch(98% 0.01 240)'
    info: str = 'oklch(70% 0.2 220)'
    info_content: str = 'oklch(98% 0.01 220)'
    success: str = 'oklch(65% 0.25 140)'
    success_content: str = 'oklch(98% 0.01 140)'
    warning: str = 'oklch(80% 0.25 80)'
    warning_content: str = 'oklch(20% 0.05 80)'
    error: str = 'oklch(65% 0.3 30)'
    error_content: str = 'oklch(98% 0.01 30)'
    
    def to_css_vars(
            self
        ) -> Dict[str, str]:  # TODO: Add return description
        "Convert to CSS variable format"
```

``` python
@dataclass
class ThemeDesignTokens:
    "Design tokens for theme customization"
    
    radius_selector: str = '1rem'  # For checkbox, toggle, badge
    radius_field: str = '0.25rem'  # For button, input, select, tab
    radius_box: str = '0.5rem'  # For card, modal, alert
    size_selector: str = '0.25rem'  # Base size for selectors
    size_field: str = '0.25rem'  # Base size for fields
    border: str = '1px'  # Border width
    depth: Literal[0, 1] = 1  # Shadow and 3D effect (0 or 1)
    noise: Literal[0, 1] = 0  # Noise texture effect (0 or 1)
    
    def to_css_vars(
            self
        ) -> Dict[str, str]:  # TODO: Add return description
        "Convert to CSS variable format"
```

``` python
@dataclass
class CustomTheme:
    "Complete custom theme definition"
    
    name: str
    is_default: bool = False
    is_prefers_dark: bool = False
    color_scheme: Literal['light', 'dark'] = 'light'
    colors: ColorScheme = field(...)
    tokens: ThemeDesignTokens = field(...)
    
    def to_css(
            self
        ) -> str:  # TODO: Add return description
        "Generate CSS for the custom theme"
```

``` python
class ConfigManager:
    "Manage daisyUI configuration persistence"
    
    def save_to_file(
            config: DaisyUIConfig,  # TODO: Add description
            path: Union[str, Path]  # TODO: Add description
        ): # TODO: Add type hint
        "Save configuration to a CSS file"
    
    def save_custom_theme(
            theme: CustomTheme,  # TODO: Add description
            path: Union[str, Path]  # TODO: Add description
        ): # TODO: Add type hint
        "Save custom theme to a CSS file"
    
    def combine_with_custom_themes(
            config: DaisyUIConfig,  # TODO: Add description
            custom_themes: List[CustomTheme]  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Combine configuration with custom themes"
```

### Component Factory (`factory.ipynb`)

> Factory functions for creating daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.factory import (
    create_simple_component
)
```

#### Functions

``` python
def create_simple_component(
    component_name: str,    # The daisyUI class name (e.g., 'badge', 'kbd')
    tag: str = "div",    # HTML tag to use (default: 'div')
    supports_color: bool = False,    # Whether component supports color modifiers
    supports_size: bool = False,    # Whether component supports size modifiers
    default_attrs: Optional[Dict[str, Any]] = None,
    class_name: Optional[str] = None    # Optional class name (defaults to PascalCase of component_name)
) -> Type[DaisyComponent]:  # A DaisyComponent subclass
    "Factory for creating simple daisyUI components. This factory creates a component class for simple daisyUI components that don't require complex logic."
```

### HTMX Integration (`htmx.ipynb`)

> HTMX patterns and helpers for daisyUI components in FastHTML

#### Import

``` python
from cjm_fasthtml_daisyui.core.htmx import (
    HTMXTrigger,
    HTMXSwap,
    HTMXAttrs,
    HTMXComponent,
    HTMXPatterns,
    HTMXModal,
    HTMXDropdown,
    HTMXForm,
    htmx_attrs,
    loading_indicator,
    oob_alert
)
```

#### Functions

``` python
def htmx_attrs(
    **kwargs
) -> Dict[str, Any]:  # Dictionary with proper HTMX attribute names
    "Convert keyword arguments to HTMX attributes Converts Python-style names to HTMX attribute names: - get -> hx-get - trigger -> hx-trigger - etc."
```

``` python
def loading_indicator(
    indicator_id: str,  # ID for the indicator
    text: str = "Loading...",  # Loading text
    size: str = "md"  # Size of spinner (xs, sm, md, lg, xl)
) -> FT:  # Loading indicator element
    "Create a loading indicator element"
```

``` python
def oob_alert(
    message: str,  # Alert message
    alert_type: str = "info",  # Type (info, success, warning, error)
    target_id: str = "alerts",  # ID of container to append to
    auto_dismiss: Optional[int] = 5000  # Auto dismiss after milliseconds (None to disable)
) -> FT:  # Alert element with OOB swap
    "Create out-of-band alert message"
```

#### Classes

``` python
class HTMXTrigger(str, Enum):
    "Common HTMX trigger events"
    
    def with_modifier(
            self,
            modifier: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add modifier to trigger (e.g., 'click once')"
    
    def delayed(
            self,
            delay: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add delay to trigger (e.g., 'keyup delay:500ms')"
    
    def changed(
            self
        ) -> str:  # TODO: Add return description
        "Add changed modifier (e.g., 'keyup changed')"
```

``` python
class HTMXSwap(str, Enum):
    "HTMX swap strategies"
    
    def with_modifier(
            self,
            modifier: str  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add swap modifier (e.g., 'innerHTML swap:500ms')"
    
    def with_transition(
            self,
            duration: str = "500ms"  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Add swap transition"
```

``` python
@dataclass
class HTMXAttrs:
    "Container for HTMX attributes"
    
    hx_get: Optional[str]
    hx_post: Optional[str]
    hx_put: Optional[str]
    hx_patch: Optional[str]
    hx_delete: Optional[str]
    hx_trigger: Optional[str]
    hx_target: Optional[str]
    hx_swap: Optional[str]
    hx_indicator: Optional[str]
    hx_push_url: Optional[Union[bool, str]]
    hx_select: Optional[str]
    hx_select_oob: Optional[str]
    hx_vals: Optional[Union[str, Dict[str, Any]]]
    hx_confirm: Optional[str]
    hx_disable: Optional[bool]
    hx_disabled_elt: Optional[str]
    hx_include: Optional[str]
    hx_ext: Optional[str]
    
    def to_dict(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Convert to dictionary of attributes"
```

``` python
class HTMXComponent:
    def __init__(self, *args, htmx: Optional[HTMXAttrs] = None, **kwargs):
        "TODO: Add function description"
        super().__init__(*args, **kwargs)
        self.htmx = htmx or HTMXAttrs()
    
    def with_htmx(
        self,
        get: Optional[str] = None,  # TODO: Add description
        post: Optional[str] = None,  # TODO: Add description
        put: Optional[str] = None,  # TODO: Add description
        patch: Optional[str] = None,  # TODO: Add description
        delete: Optional[str] = None,  # TODO: Add description
        trigger: Optional[Union[HTMXTrigger, str]] = None,
        target: Optional[str] = None,  # TODO: Add description
        swap: Optional[Union[HTMXSwap, str]] = None,
        **kwargs
    ) -> 'HTMXComponent':  # TODO: Add return description
    """
    Base class for HTMX-aware daisyUI components
    
    Extends DaisyComponent with HTMX attributes and helper methods
    for building interactive components following FastHTML patterns.
    """
    
    def __init__(self, *args, htmx: Optional[HTMXAttrs] = None, **kwargs):
            "TODO: Add function description"
            super().__init__(*args, **kwargs)
            self.htmx = htmx or HTMXAttrs()
        
        def with_htmx(
            self,
            get: Optional[str] = None,  # TODO: Add description
            post: Optional[str] = None,  # TODO: Add description
            put: Optional[str] = None,  # TODO: Add description
            patch: Optional[str] = None,  # TODO: Add description
            delete: Optional[str] = None,  # TODO: Add description
            trigger: Optional[Union[HTMXTrigger, str]] = None,
            target: Optional[str] = None,  # TODO: Add description
            swap: Optional[Union[HTMXSwap, str]] = None,
            **kwargs
        ) -> 'HTMXComponent':  # TODO: Add return description
        "TODO: Add function description"
    
    def with_htmx(
            self,
            get: Optional[str] = None,  # TODO: Add description
            post: Optional[str] = None,  # TODO: Add description
            put: Optional[str] = None,  # TODO: Add description
            patch: Optional[str] = None,  # TODO: Add description
            delete: Optional[str] = None,  # TODO: Add description
            trigger: Optional[Union[HTMXTrigger, str]] = None,
            target: Optional[str] = None,  # TODO: Add description
            swap: Optional[Union[HTMXSwap, str]] = None,
            **kwargs
        ) -> 'HTMXComponent':  # TODO: Add return description
        "Configure HTMX attributes fluently

Args:
    get/post/put/patch/delete: URL endpoints
    trigger: Event that triggers the request
    target: CSS selector for target element
    swap: How to swap the response
    **kwargs: Additional HTMX attributes
    
Returns:
    Self for method chaining"
    
    def with_loading(
            self,
            indicator_id: str,  # TODO: Add description
            disable_during: Optional[str] = None  # TODO: Add description
        ) -> 'HTMXComponent':  # TODO: Add return description
        "Configure loading indicators

Args:
    indicator_id: ID of the loading indicator element
    disable_during: CSS selector of elements to disable during request
    
Returns:
    Self for method chaining"
    
    def with_confirmation(
            self,
            message: str  # TODO: Add description
        ) -> 'HTMXComponent':  # TODO: Add return description
        "Add confirmation dialog

Args:
    message: Confirmation message to show
    
Returns:
    Self for method chaining"
    
    def render_attrs(
            self
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Build all HTML attributes including HTMX"
```

``` python
class HTMXPatterns:
    "Common HTMX patterns for daisyUI components"
    
    def live_search(
            input_id: str,  # TODO: Add description
            results_id: str,  # TODO: Add description
            endpoint: str,  # TODO: Add description
            min_length: int = 2,  # TODO: Add description
            delay: str = "500ms"  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create live search pattern

Args:
    input_id: ID for the search input
    results_id: ID for the results container
    endpoint: Search endpoint URL
    min_length: Minimum characters before searching
    delay: Debounce delay
    
Returns:
    Dictionary of attributes for the input element"
    
    def infinite_scroll(
            container_id: str,  # TODO: Add description
            next_page_endpoint: str,  # TODO: Add description
            threshold: str = "100px"  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create infinite scroll pattern

Args:
    container_id: ID of the container element
    next_page_endpoint: Endpoint for next page
    threshold: How far from bottom to trigger
    
Returns:
    Dictionary of attributes for the sentinel element"
    
    def click_to_edit(
            display_id: str,  # TODO: Add description
            edit_endpoint: str,  # TODO: Add description
            update_endpoint: str  # TODO: Add description
        ) -> Tuple[Dict[str, Any], Dict[str, Any]]:  # TODO: Add return description
        "Create click-to-edit pattern

Args:
    display_id: ID of the display element
    edit_endpoint: Endpoint to get edit form
    update_endpoint: Endpoint to save changes
    
Returns:
    Tuple of (display_attrs, form_attrs)"
    
    def delete_with_confirm(
            element_id: str,  # TODO: Add description
            delete_endpoint: str,  # TODO: Add description
            confirm_message: str = "Are you sure you want to delete this?"  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create delete with confirmation pattern

Args:
    element_id: ID of element to delete
    delete_endpoint: Delete endpoint URL
    confirm_message: Confirmation message
    
Returns:
    Dictionary of attributes for delete button"
    
    def poll_for_updates(
            element_id: str,  # TODO: Add description
            poll_endpoint: str,  # TODO: Add description
            interval: str = "2s"  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create polling pattern for live updates

Args:
    element_id: ID of element to update
    poll_endpoint: Endpoint to poll
    interval: Polling interval
    
Returns:
    Dictionary of attributes"
```

``` python
class HTMXModal:
    "HTMX patterns for modal components"
    
    def trigger_button(
            modal_id: str,  # TODO: Add description
            text: str,  # TODO: Add description
            endpoint: Optional[str] = None,  # TODO: Add description
            button_class: str = "btn btn-primary"  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create a button that opens a modal

Args:
    modal_id: ID of the modal dialog element
    text: Button text
    endpoint: Optional endpoint to load modal content
    button_class: CSS classes for button
    
Returns:
    Button element with proper attributes"
    
    def close_button(
            modal_id: str,  # TODO: Add description
            text: str = "Close",  # TODO: Add description
            button_class: str = "btn"  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create a close button for modal

Args:
    modal_id: ID of the modal to close
    text: Button text
    button_class: CSS classes
    
Returns:
    Close button element"
    
    def async_modal(
            modal_id: str,  # TODO: Add description
            title: str,  # TODO: Add description
            content_endpoint: str  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create a modal that loads content asynchronously

Args:
    modal_id: ID for the modal
    title: Modal title
    content_endpoint: Endpoint to load content from
    
Returns:
    Modal dialog element"
```

``` python
class HTMXDropdown:
    "HTMX patterns for dropdown components"
    
    def lazy_dropdown(
            dropdown_id: str,  # TODO: Add description
            button_text: str,  # TODO: Add description
            content_endpoint: str,  # TODO: Add description
            button_class: str = "btn"  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create dropdown that loads content on first open

Args:
    dropdown_id: ID for the dropdown
    button_text: Text for dropdown button
    content_endpoint: Endpoint to load content
    button_class: CSS classes for button
    
Returns:
    Dropdown element"
    
    def search_dropdown(
            dropdown_id: str,  # TODO: Add description
            search_endpoint: str,  # TODO: Add description
            placeholder: str = "Search..."  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create dropdown with search functionality

Args:
    dropdown_id: ID for the dropdown
    search_endpoint: Endpoint for search
    placeholder: Search input placeholder
    
Returns:
    Searchable dropdown element"
```

``` python
class HTMXForm:
    "HTMX patterns for form components"
    
    def ajax_form(
            form_id: str,  # TODO: Add description
            endpoint: str,  # TODO: Add description
            method: str = "post",  # TODO: Add description
            success_target: Optional[str] = None,  # TODO: Add description
            loading_text: str = "Submitting..."  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create AJAX form attributes

Args:
    form_id: ID for the form
    endpoint: Form submission endpoint
    method: HTTP method
    success_target: Target for success response
    loading_text: Text to show while submitting
    
Returns:
    Dictionary of form attributes"
    
    def inline_validation(
            input_id: str,  # TODO: Add description
            validation_endpoint: str,  # TODO: Add description
            error_target: str  # TODO: Add description
        ) -> Dict[str, Any]:  # TODO: Add return description
        "Create inline validation pattern

Args:
    input_id: ID of input to validate
    validation_endpoint: Validation endpoint
    error_target: Where to show errors
    
Returns:
    Dictionary of input attributes"
    
    def submit_button_with_loading(
            text: str = "Submit",  # TODO: Add description
            loading_text: str = "Submitting...",  # TODO: Add description
            button_class: str = "btn btn-primary"  # TODO: Add description
        ) -> FT:  # TODO: Add return description
        "Create submit button with loading state

Args:
    text: Button text
    loading_text: Text during loading
    button_class: CSS classes
    
Returns:
    Button element with loading indicator"
```

### Component Parts (`parts.ipynb`)

> System for handling component parts (e.g., card-body, modal-box)

#### Import

``` python
from cjm_fasthtml_daisyui.core.parts import (
    ComponentPart,
    HasParts
)
```

#### Classes

``` python
@dataclass
class ComponentPart:
    """
    Represents a part of a component (e.g., card-body, modal-box).
    
    Component parts are child elements that have specific styling
    within their parent component context.
    """
    
    name: str  # Part name (e.g., 'body', 'title', 'actions')
    parent_component: str  # Parent component name (e.g., 'card', 'modal')
    required: bool = False  # Whether this part is required
    tag: str = 'div'  # Default HTML tag for this part
    
    def class_name(
            self
        ) -> str:  # TODO: Add return description
        "Return the full class name for this part."
```

``` python
class HasParts:
    """
    Mixin for components that have child parts.
    
    This mixin provides functionality for components like cards, modals,
    and other complex components that have defined child elements.
    """
    
    def parts(
            cls  # TODO: Add type hint and description
        ) -> Dict[str, ComponentPart]:  # TODO: Add return description
        "Return all available parts for this component.

Subclasses should override this to define their parts."
    
    def part(
            self,
            name: str,  # TODO: Add description
            *children,
            **attrs
        ) -> Any:  # TODO: Add return description
        "Create a component part element.

Args:
    name: The part name (must be defined in parts())
    *children: Child elements for this part
    **attrs: HTML attributes for the part
    
Returns:
    FastHTML element with the appropriate part classes"
```

### Placement & Direction (`placement.ipynb`)

> Mixins for component placement and direction options

#### Import

``` python
from cjm_fasthtml_daisyui.core.placement import (
    HasPlacement,
    HasDirection,
    HasPlacementAndDirection
)
```

#### Classes

``` python
class HasPlacement(CSSContributor):
    """
    Mixin for components with placement options.
    
    This mixin provides functionality for components that can be
    positioned in different locations (start, center, end, top, bottom, etc.).
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get placement classes.
            
            Returns:
                List of CSS class strings for placement
            """
            if not self.placement
        "Get placement classes.

Returns:
    List of CSS class strings for placement"
    
    def uses_standard_placement(
            self
        ) -> bool:  # TODO: Add return description
        "Whether component uses standard '{component}-{placement}' pattern."
    
    def custom_placement_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Override for custom placement class patterns."
    
    def valid_placements(
            self
        ) -> List[str]:  # TODO: Add return description
        "Return list of valid placement values for this component."
```

``` python
class HasDirection(CSSContributor):
    """
    Mixin for components with direction options.
    
    This mixin provides functionality for components that can have
    different directional layouts (horizontal, vertical).
    """
    
    def get_css_classes(self) -> CSSClasses:
            """Get direction classes.
            
            Returns:
                List of CSS class strings for direction
            """
            if not self.direction
        "Get direction classes.

Returns:
    List of CSS class strings for direction"
    
    def is_horizontal(
            self
        ) -> bool:  # TODO: Add return description
        "Check if component is horizontal."
    
    def is_vertical(
            self
        ) -> bool:  # TODO: Add return description
        "Check if component is vertical."
```

``` python
class HasPlacementAndDirection(HasPlacement, HasDirection):
    """
    Combined mixin for components with both placement and direction.
    
    This is useful for components like toast, divider, etc. that
    support both placement and direction options.
    """
    
    def get_css_classes(self) -> CSSClasses
        "Get combined placement and direction classes.

Returns:
    List of CSS class strings for placement and direction"
```

### Resources (`resources.ipynb`)

> Managing daisyUI and Tailwind CSS resources for FastHTML projects

#### Import

``` python
from cjm_fasthtml_daisyui.core.resources import (
    CDNProvider,
    ResourceVersions,
    DaisyUIResources,
    ResourcePresets,
    ResourceOptimization,
    ResourceManager
)
```

#### Classes

``` python
class CDNProvider(str, Enum):
    "Supported CDN providers for daisyUI and Tailwind CSS"
    
    def get_base_url(
            self
        ) -> str:  # TODO: Add return description
        "Get the base URL for the CDN provider"
```

``` python
@dataclass
class ResourceVersions:
    "Version management for daisyUI and Tailwind CSS"
    
    daisyui: str = '5'
    tailwind: str = '4'
    
    def get_daisyui_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for daisyUI"
    
    def get_daisyui_themes_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for daisyUI themes"
    
    def get_tailwind_url(
            self,
            provider: CDNProvider = CDNProvider.JSDELIVR  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Get the full CDN URL for Tailwind CSS browser version"
```

``` python
class DaisyUIResources:
    "Manages daisyUI and Tailwind CSS resources for FastHTML projects"
    
    def cdn_headers(
            versions: Optional[ResourceVersions] = None,  # TODO: Add description
            provider: CDNProvider = CDNProvider.JSDELIVR,  # TODO: Add description
            include_tailwind: bool = True,  # TODO: Add description
            additional_css: Optional[List[str]] = None,  # TODO: Add description
            additional_js: Optional[List[str]] = None  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "CDN-based resources for quick testing and development

Args:
    versions: Version configuration (defaults to latest stable)
    provider: CDN provider to use
    include_tailwind: Whether to include Tailwind CSS browser version
    additional_css: Extra CSS files to include
    additional_js: Extra JS files to include
    
Returns:
    List of FastHTML header elements"
    
    def local_headers(
            css_path: str = "/static/styles.css",  # TODO: Add description
            js_paths: Optional[List[str]] = None,  # TODO: Add description
            additional_css: Optional[List[str]] = None,  # TODO: Add description
            additional_js: Optional[List[str]] = None  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Local file-based resources for production use

Args:
    css_path: Path to compiled CSS file containing Tailwind + daisyUI
    js_paths: Paths to any JavaScript files
    additional_css: Extra CSS files to include
    additional_js: Extra JS files to include
    
Returns:
    List of FastHTML header elements"
    
    def inline_css(
            content: str,  # TODO: Add description
            id: Optional[str] = None  # TODO: Add description
        ) -> Style:  # TODO: Add return description
        "Create an inline CSS style element

Args:
    content: CSS content to inline
    id: Optional ID for the style element
    
Returns:
    FastHTML Style element"
    
    def minimal_css(
        ) -> str:  # TODO: Add return description
        "Get minimal CSS for Tailwind v4 with daisyUI plugin

Returns:
    CSS string with Tailwind and daisyUI imports"
```

``` python
class ResourcePresets:
    "Common resource configurations"
    
    def development(
        ) -> List[FT]:  # TODO: Add return description
        "Quick development setup with CDN resources"
    
    def production(
            css_path: str = "/static/styles.css"  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Production setup with compiled CSS"
    
    def testing(
        ) -> List[FT]:  # TODO: Add return description
        "Testing setup with fast CDN and no caching"
    
    def offline(
            css_path: str = "/static/daisyui.css",  # TODO: Add description
            tailwind_path: str = "/static/tailwind.js"  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Completely offline setup with local files"
```

``` python
@dataclass
class ResourceOptimization:
    "Advanced resource optimization options"
    
    preload: bool = True
    prefetch: bool = False
    async_load: bool = False
    defer: bool = False
    integrity: Optional[str]
    crossorigin: Optional[str] = 'anonymous'
    
    def apply_to_link(
            self,
            link_attrs: Dict[str, str]  # TODO: Add description
        ) -> Dict[str, str]:  # TODO: Add return description
        "Apply optimization attributes to a link element"
    
    def apply_to_script(
            self,
            script_attrs: Dict[str, str]  # TODO: Add description
        ) -> Dict[str, str]:  # TODO: Add return description
        "Apply optimization attributes to a script element"
```

``` python
class ResourceManager:
    def __init__(self):
        "TODO: Add function description"
        self._cache: Dict[str, List[FT]] = {}
    "Advanced resource manager with caching and optimization"
    
    def __init__(self):
            "TODO: Add function description"
            self._cache: Dict[str, List[FT]] = {}
        "TODO: Add function description"
    
    def get_optimized_headers(
            self,
            key: str = "default",  # TODO: Add description
            force_refresh: bool = False  # TODO: Add description
        ) -> List[FT]:  # TODO: Add return description
        "Get cached headers with optimization"
    
    def clear_cache(
            self
        ): # TODO: Add type hint
        "Clear the resource cache"
```

### Testing (`testing.ipynb`)

> Standardized testing framework for daisyUI components in Jupyter
> notebooks

#### Import

``` python
from cjm_fasthtml_daisyui.core.testing import (
    DisplayMode,
    ComponentExample,
    ComponentTester,
    quick_test,
    test_variants,
    theme_test,
    ComponentBuilder,
    TestData
)
```

#### Functions

``` python
def quick_test(
    *components: FT,
    title: str = "Quick Test"  # Title for the test page
) -> ComponentTester:  # Started ComponentTester instance
    "Quick function to test components"
```

``` python
def test_variants(
    component_fn: Callable,  # Function that creates the component
    variants: Dict[str, List[Any]],
    base_props: Optional[Dict[str, Any]] = None,
    title: str = "Variant Testing"  # Title for the test page
) -> ComponentTester:  # Started ComponentTester instance
    "Test multiple variants of a component"
```

``` python
@contextmanager
def theme_test(
    themes: Optional[List[Union[DaisyUITheme, str]]] = None  # List of themes to test with (uses all themes if None)
)
    "Context manager for testing with specific themes"
```

#### Classes

``` python
class DisplayMode(str, Enum):
    "Component display modes for testing"
```

``` python
@dataclass
class ComponentExample:
    "Container for a component example with metadata"
    
    component: FT
    title: str
    description: Optional[str]
    code: Optional[str]
    props: Optional[Dict[str, Any]]
```

``` python
class ComponentTester:
    def __init__(
        self,
        title: str = "Component Showcase",  # TODO: Add description
        pico: bool = False,  # TODO: Add description
        config: Optional[DaisyUIConfig] = None,  # TODO: Add description
        use_cdn: bool = True,  # TODO: Add description
        port: Optional[int] = 8000,  # TODO: Add description
        available_themes: Optional[List[Union[DaisyUITheme, str]]] = None
    )
    """
    Standardized testing framework for daisyUI components in notebooks
    
    Provides an interactive environment for testing and showcasing components
    with theme switching, responsive preview, and documentation.
    """
    
    def __init__(
            self,
            title: str = "Component Showcase",  # TODO: Add description
            pico: bool = False,  # TODO: Add description
            config: Optional[DaisyUIConfig] = None,  # TODO: Add description
            use_cdn: bool = True,  # TODO: Add description
            port: Optional[int] = 8000,  # TODO: Add description
            available_themes: Optional[List[Union[DaisyUITheme, str]]] = None
        )
        "Initialize the component tester

Args:
    title: Title for the showcase page
    pico: Whether to include Pico CSS (should be False for daisyUI)
    config: daisyUI configuration (only used with local resources)
    use_cdn: Whether to use CDN resources (vs local)
    port: Port for the test server (defaults to 8000)
    available_themes: List of themes to show in selector (defaults to all when using CDN)"
    
    def add(
            self,
            component: Union[FT, Callable[[], FT]],
            title: str,  # TODO: Add description
            description: Optional[str] = None,  # TODO: Add description
            code: Optional[str] = None,  # TODO: Add description
            **props
        ) -> "ComponentTester":  # TODO: Add return description
        "Add a component example to the showcase

Args:
    component: Component or function that returns a component
    title: Title for this example
    description: Optional description
    code: Optional code snippet to display
    **props: Properties passed to the component if it's a function"
    
    def showcase(
            self,
            *components: FT,
            mode: DisplayMode = DisplayMode.SECTIONS,
            titles: Optional[List[str]] = None
        ) -> "ComponentTester":  # TODO: Add return description
        "Quick method to add multiple components

Args:
    *components: Components to showcase
    mode: How to display the components
    titles: Optional titles for each component"
    
    def start(
            self,
            open_browser: bool = False  # TODO: Add description
        ) -> "ComponentTester":  # TODO: Add return description
        "Start the test server"
    
    def stop(
            self
        ): # TODO: Add type hint
        "Stop the test server"
```

``` python
class ComponentBuilder:
    def __init__(
        self,
        title: str = "Component Builder"  # TODO: Add description
    )
    "Interactive component builder for notebooks"
    
    def __init__(
            self,
            title: str = "Component Builder"  # TODO: Add description
        )
        "TODO: Add function description"
    
    def create(
            self,
            tag: str = "div",  # TODO: Add description
            *children,
            **attrs
        ) -> "ComponentBuilder":  # TODO: Add return description
        "Create a new component"
    
    def add_class(
            self,
            *classes: str
        ) -> "ComponentBuilder":  # TODO: Add return description
        "Add classes to the current component"
    
    def add_child(
            self,
            child: FT  # TODO: Add description
        ) -> "ComponentBuilder":  # TODO: Add return description
        "Add a child to the current component"
    
    def preview(
            self,
            title: Optional[str] = None  # TODO: Add description
        ) -> "ComponentBuilder":  # TODO: Add return description
        "Preview the current component"
    
    def show(
            self
        ) -> ComponentTester:  # TODO: Add return description
        "Show all previewed components"
    
    def reset(
            self
        ) -> "ComponentBuilder":  # TODO: Add return description
        "Reset the builder"
```

``` python
class TestData:
    "Generate test data for components"
    
    def lorem(
            words: int = 10  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Generate lorem ipsum text"
    
    def image(
            width: int = 300,  # TODO: Add description
            height: int = 200,  # TODO: Add description
            category: str = ""  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Generate placeholder image URL"
    
    def avatar(
            size: int = 100,  # TODO: Add description
            seed: Optional[str] = None  # TODO: Add description
        ) -> str:  # TODO: Add return description
        "Generate avatar URL"
    
    def items(
            count: int = 5,  # TODO: Add description
            prefix: str = "Item"  # TODO: Add description
        ) -> List[str]:  # TODO: Add return description
        "Generate list of items"
    
    def table_data(
            rows: int = 5,  # TODO: Add description
            cols: int = 3  # TODO: Add description
        ) -> List[List[str]]:  # TODO: Add return description
        "Generate table data"
```

### Types (`types.ipynb`)

> Common types and type aliases for daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.types import (
    CSSClasses,
    CSSClass,
    HTMLAttrs,
    Children,
    ComponentProps,
    ResponsiveDict,
    ColorValue,
    SizeValue,
    EventHandler,
    ComponentFactory,
    HTMXValue,
    DirectionType,
    PlacementType,
    HTTPMethod,
    ColorSchemeType,
    BrandType,
    StateType,
    CommonSizeType,
    CSSContributor,
    FeatureSupport,
    ComponentProtocol,
    ensure_list,
    ensure_dict
)
```

#### Functions

``` python
def ensure_list(value: Union[str, List[str]]) -> List[str]:
    """Ensure a value is a list of strings.
    
    Args:
        value: String or list of strings
        
    Returns:
        List of strings
    """
    if isinstance(value, str)
    """
    Ensure a value is a list of strings.
    
    Args:
        value: String or list of strings
        
    Returns:
        List of strings
    """
```

``` python
def ensure_dict(value: Union[str, Dict[str, Any]]) -> Dict[str, Any]:
    """Ensure a value is a dictionary.
    
    Args:
        value: String (JSON) or dictionary
        
    Returns:
        Dictionary
    """
    if isinstance(value, str)
    """
    Ensure a value is a dictionary.
    
    Args:
        value: String (JSON) or dictionary
        
    Returns:
        Dictionary
    """
```

#### Classes

``` python
class CSSContributor(Protocol):
    """
    Protocol for mixins that contribute CSS classes.
    
    This standardizes the interface for all mixins that add CSS classes
    to components, replacing the various `*_classes()` methods.
    """
    
    def get_css_classes(self) -> CSSClasses
        "Return CSS classes from this contributor.

Returns:
    List of CSS class strings"
```

``` python
class FeatureSupport(Protocol):
    """
    Protocol for components with feature support.
    
    This standardizes the pattern of checking what features
    a component supports (color, size, glass, etc.).
    """
    
    def get_supported_features(self) -> Dict[str, bool]
        "Return dictionary of supported features.

Returns:
    Dictionary mapping feature names to support status
    
Example:
    {
        'color': True,
        'size': True,
        'glass': False,
        'active': True,
        'disabled': True,
        'loading': False
    }"
```

``` python
class ComponentProtocol(Protocol):
    """
    Base protocol for all daisyUI components.
    
    Defines the minimum interface that all components must implement.
    """
    
    def component_class(self) -> str:
            """Return the base component class name."""
            ...
        
        def build_classes(self) -> str
        "Return the base component class name."
    
    def build_classes(self) -> str:
            """Build complete class string."""
            ...
        
        def render_attrs(self) -> HTMLAttrs
        "Build complete class string."
    
    def render_attrs(self) -> HTMLAttrs
        "Build all HTML attributes for rendering."
```

#### Variables

``` python
ColorValue  # Forward reference
SizeValue  # Forward reference
```

### Utilities (`utils.ipynb`)

> Shared utility functions for daisyUI components

#### Import

``` python
from cjm_fasthtml_daisyui.core.utils import (
    create_element
)
```

#### Functions

``` python
def create_element(
    tag: str,  # HTML tag name (e.g., 'div', 'span', 'button')
    *children,  # Child elements
    **attrs  # HTML attributes
) -> FT:  # FastHTML element
    """
    Create a FastHTML element from a tag name.
    
    This function provides a centralized way to create HTML elements,
    avoiding duplication across modules.
    
    Args:
        tag: The HTML tag name (case-insensitive)
        *children: Child elements to include
        **attrs: HTML attributes for the element
        
    Returns:
        A FastHTML element of the specified type
        
    Examples:
        >>> create_element('div', 'Hello', cls='container')
        >>> create_element('button', 'Click me', type='submit')
    """
```

### Validation (`validation.ipynb`)

> Enforcing daisyUI 5 usage rules and best practices

#### Import

``` python
from cjm_fasthtml_daisyui.core.validation import (
    ValidationLevel,
    ValidationMessage,
    ValidationResult,
    DaisyUIRules,
    ComponentValidators,
    validate_classes,
    assert_valid,
    ValidatedComponent
)
```

#### Functions

``` python
def validate_classes(classes: Union[str, List[str]], 
                    strict: bool = False) -> ValidationResult
    "Quick validation of CSS classes"
```

``` python
def assert_valid(component: DaisyComponent, 
                message: str = "Component validation failed")
    "Assert that a component is valid, raising an exception if not"
```

#### Classes

``` python
class ValidationLevel(str, Enum):
    "Severity levels for validation messages"
    
    def symbol(
            self
        ) -> str:  # TODO: Add return description
        "Get symbol for this level"
```

``` python
@dataclass
class ValidationMessage:
    "A single validation message"
    
    level: ValidationLevel
    message: str
    rule: str  # Which daisyUI rule this relates to
    suggestion: Optional[str]
    context: Optional[Dict[str, Any]]
    
```

``` python
@dataclass
class ValidationResult:
    "Result of validating a component or set of classes"
    
    messages: List[ValidationMessage] = field(...)
    
    def is_valid(
            self
        ) -> bool:  # TODO: Add return description
        "Check if validation passed (no errors)"
    
    def has_warnings(
            self
        ) -> bool:  # TODO: Add return description
        "Check if there are any warnings"
    
    def add(self, level: ValidationLevel, message: str, rule: str,
                suggestion: Optional[str] = None, context: Optional[Dict[str, Any]] = None)
        "Add a validation message"
    
    def get_by_level(
            self,
            level: ValidationLevel  # TODO: Add description
        ) -> List[ValidationMessage]:  # TODO: Add return description
        "Get all messages of a specific level"
    
    def summary(
            self
        ) -> str:  # TODO: Add return description
        "Get a summary of validation results"
```

``` python
class DaisyUIRules:
    """
    Enforces daisyUI 5 usage rules
    
    Based on the official daisyUI 5 usage rules:
    1. Components need component class + optional part/modifier classes
    2. Customization via Tailwind utilities (use ! for specificity issues)
    3. Create custom components with Tailwind if not in daisyUI
    4. Responsive layouts should use Tailwind responsive prefixes
    5. Use daisyUI or Tailwind classes only
    6. Prefer semantic colors over hardcoded Tailwind colors
    7. Avoid hardcoded colors that won't adapt to themes
    """
    
    def validate_color_usage(
            cls,  # TODO: Add type hint and description
            classes: Union[str, List[str]]  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Validate color usage (Rules 6-9)

Checks for:
- Hardcoded Tailwind colors that won't adapt to themes
- Suggests semantic colors instead"
    
    def validate_component_structure(
            cls,  # TODO: Add type hint and description
            component: DaisyComponent  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Validate component structure (Rule 1)

Checks for:
- Proper component class naming
- Valid modifier usage"
    
    def suggest_responsive(
            cls,  # TODO: Add type hint and description
            classes: Union[str, List[str]]  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Suggest responsive improvements (Rule 4)

Checks for:
- Components that might benefit from responsive modifiers"
    
    def validate_custom_css(cls, classes: Union[str, List[str]],
                               allow_arbitrary: bool = True) -> ValidationResult
        "Validate against custom CSS (Rules 5-7)

Checks for:
- Non-daisyUI/Tailwind classes
- Arbitrary values (which are allowed but tracked)"
    
    def validate_all(cls, component: DaisyComponent,
                        check_responsive: bool = True) -> ValidationResult
        "Run all validation rules on a component

Args:
    component: The component to validate
    check_responsive: Whether to check for responsive suggestions
    
Returns:
    Combined validation results"
```

``` python
class ComponentValidators:
    "Validators for specific component types"
    
    def validate_button(
            classes: str  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Validate button-specific rules"
    
    def validate_form_control(
            classes: str,  # TODO: Add description
            component_type: str  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Validate form control components (input, select, textarea)"
    
    def validate_modal(
            classes: str,  # TODO: Add description
            has_trigger: bool = False  # TODO: Add description
        ) -> ValidationResult:  # TODO: Add return description
        "Validate modal component structure"
```

``` python
class ValidatedComponent:
    def __init__(self, *args, validate_on_init: bool = True, **kwargs):
        "TODO: Add function description"
        super().__init__(*args, **kwargs)
        self.validate_on_init = validate_on_init
        
        if validate_on_init
    """
    Base class for components with automatic validation
    
    Subclasses will have their output validated automatically
    to ensure compliance with daisyUI rules.
    """
    
    def __init__(self, *args, validate_on_init: bool = True, **kwargs):
            "TODO: Add function description"
            super().__init__(*args, **kwargs)
            self.validate_on_init = validate_on_init
            
            if validate_on_init
        "TODO: Add function description"
    
    def build_classes(
            self
        ) -> str:  # TODO: Add return description
        "Build classes with validation"
```

### Variant System (`variants.ipynb`)

> System for handling component variants and states

#### Import

``` python
from cjm_fasthtml_daisyui.core.variants import (
    STYLE_VARIANT,
    StyleType,
    Variant,
    HasVariants,
    CompoundVariant,
    HasCompoundVariants,
    create_style_variant
)
```

#### Functions

``` python
def create_style_variant(component_prefix: str) -> Variant
    """
    Create a style variant with component-specific class names.
    
    Args:
        component_prefix: The component prefix (e.g., 'btn', 'badge')
        
    Returns:
        Variant with component-specific style classes
    """
```

#### Classes

``` python
class StyleType(str, Enum):
    """
    Common style modifiers across components.
    
    These were previously in modifiers.ipynb but are now part of the
    unified variant system.
    """
```

``` python
@dataclass
class Variant:
    """
    Represents a component variant.
    
    Variants allow components to have different appearances based on props.
    Inspired by CVA (Class Variance Authority) pattern.
    """
    
    name: str  # Variant name (e.g., 'intent', 'size')
    options: Dict[str, Union[str, List[str]]]  # Option -> classes mapping
    default: Optional[str]  # Default option
    
    def get_classes(
            self,
            value: Optional[str]  # TODO: Add description
        ) -> List[str]:  # TODO: Add return description
        "Get classes for a variant value."
```

``` python
class HasVariants(CSSContributor):
    """
    Mixin for components with variant support.
    
    This provides a more flexible alternative to individual boolean flags
    for component variations.
    """
    
    def variants(
            cls  # TODO: Add type hint and description
        ) -> Dict[str, Variant]:  # TODO: Add return description
        "Define available variants.

Subclasses should override this to define their variants."
    
    def get_css_classes(self) -> CSSClasses:
            """Get all classes from variants.
            
            Returns:
                List of CSS class strings from variants
            """
            classes = []
            variants = self.variants()
            
            for variant_name, variant in variants.items()
        "Get all classes from variants.

Returns:
    List of CSS class strings from variants"
    
    def set_variant(
            self,
            name: str,  # TODO: Add description
            value: str  # TODO: Add description
        ) -> 'HasVariants':  # TODO: Add return description
        "Set a variant value and return self for chaining."
```

``` python
@dataclass
class CompoundVariant:
    "Represents a compound variant that depends on multiple conditions."
    
    conditions: Dict[str, str]  # variant_name -> required_value
    classes: Union[str, List[str]]  # Classes to apply when conditions met
    
    def matches(
            self,
            variant_values: Dict[str, Optional[str]]  # TODO: Add description
        ) -> bool:  # TODO: Add return description
        "Check if all conditions are met."
    
    def get_classes(
            self
        ) -> List[str]:  # TODO: Add return description
        "Get classes for this compound variant."
```

``` python
class HasCompoundVariants(HasVariants):
    "Extended mixin that supports compound variants."
    
    def compound_variants(
            cls  # TODO: Add type hint and description
        ) -> List[CompoundVariant]:  # TODO: Add return description
        "Define compound variants.

Subclasses should override this to define compound variants."
    
    def get_css_classes(self) -> CSSClasses:
            """Get all classes from variants including compound variants.
            
            Returns:
                List of CSS class strings from variants and compound variants
            """
            classes = super().get_css_classes()
            
            # Check compound variants
            for compound in self.compound_variants()
        "Get all classes from variants including compound variants.

Returns:
    List of CSS class strings from variants and compound variants"
```

#### Variables

``` python
STYLE_VARIANT
```
